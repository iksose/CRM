compiled/src/vendor.js:667:  // TODO: we should move this into IE/ES5 polyfill
compiled/src/vendor.js:1481://TODO(misko): this function needs to be removed
compiled/src/vendor.js:3965:    // TODO(vojta): use filter if we change it to accept lists as well
compiled/src/vendor.js:4295:  // TODO(vojta): remove this temporary api
compiled/src/vendor.js:4323:   * TODO(vojta): prefix this method with $$ ?
compiled/src/vendor.js:4473:    // TODO(vojta): refactor to use node's syntax for events
compiled/src/vendor.js:5755:        // TODO: decide whether or not to throw an error if "class"
compiled/src/vendor.js:6896:                // TODO(i): this should likely be attr.$set(name, iterpolateFn(scope) so that we reset the
compiled/src/vendor.js:8301:  // TODO(vojta): fix the signature
compiled/src/vendor.js:9544:      // TODO(vojta): rewrite link when opening in new tab/window (in legacy browser)
compiled/src/vendor.js:10201:    //TODO(i): strip all the obsolte json stuff from this file
compiled/src/vendor.js:10343:        // TODO(size): maybe we should not support multiple statements?
compiled/src/vendor.js:17852:    // TODO: move this to scenario runner
compiled/src/vendor.js:21217:        // TODO(vojta): can't we optimize this ?
compiled/src/vendor.js:23430:      //TODO: this should happen before the "delayed" watches fire, because if some cookies are not
compiled/src/vendor.js:24101:        // TODO: do this mathmatically instead of through conditions
compiled/src/vendor.js:24205:  // TODO(vojta): remove this temporary api
compiled/src/vendor.js:25010:        // TODO(i): this prevents methods being logged,
compiled/src/vendor.js:25269:  // TODO(vojta): change params to: method, url, data, headers, callback
compiled/src/vendor.js:27775:// @TODO: submit issue to core
compiled/src/vendor.js:43047:/* jquery.signalR.core.js *//*global window:false *//*! * ASP.NET SignalR JavaScript Library v2.0.3 * http://signalr.net/ * * Copyright (C) Microsoft Corporation. All rights reserved. * *//// <reference path="Scripts/jquery-1.6.4.js" />/// <reference path="jquery.signalR.version.js" />(function ($, window, undefined) {    "use strict";    var resources = {        nojQuery: "jQuery was not found. Please ensure jQuery is referenced before the SignalR client JavaScript file.",        noTransportOnInit: "No transport could be initialized successfully. Try specifying a different transport or none at all for auto initialization.",        errorOnNegotiate: "Error during negotiation request.",        stoppedWhileLoading: "The connection was stopped during page load.",        stoppedWhileNegotiating: "The connection was stopped during the negotiate request.",        errorParsingNegotiateResponse: "Error parsing negotiate response.",        protocolIncompatible: "You are using a version of the client that isn't compatible with the server. Client version {0}, server version {1}.",        sendFailed: "Send failed.",        parseFailed: "Failed at parsing response: {0}",        longPollFailed: "Long polling request failed.",        eventSourceFailedToConnect: "EventSource failed to connect.",        eventSourceError: "Error raised by EventSource",        webSocketClosed: "WebSocket closed.",        pingServerFailedInvalidResponse: "Invalid ping response when pinging server: '{0}'.",        pingServerFailed: "Failed to ping server.",        pingServerFailedStatusCode: "Failed to ping server.  Server responded with status code {0}, stopping the connection.",        pingServerFailedParse: "Failed to parse ping server response, stopping the connection.",        noConnectionTransport: "Connection is in an invalid state, there is no transport active.",        webSocketsInvalidState: "The Web Socket transport is in an invalid state, transitioning into reconnecting."    };    if (typeof ($) !== "function") {        // no jQuery!        throw new Error(resources.nojQuery);    }    var signalR,        _connection,        _pageLoaded = (window.document.readyState === "complete"),        _pageWindow = $(window),        _negotiateAbortText = "__Negotiate Aborted__",        events = {            onStart: "onStart",            onStarting: "onStarting",            onReceived: "onReceived",            onError: "onError",            onConnectionSlow: "onConnectionSlow",            onReconnecting: "onReconnecting",            onReconnect: "onReconnect",            onStateChanged: "onStateChanged",            onDisconnect: "onDisconnect"        },        ajaxDefaults = {            processData: true,            timeout: null,            async: true,            global: false,            cache: false        },        log = function (msg, logging) {            if (logging === false) {                return;            }            var m;            if (typeof (window.console) === "undefined") {                return;            }            m = "[" + new Date().toTimeString() + "] SignalR: " + msg;            if (window.console.debug) {                window.console.debug(m);            } else if (window.console.log) {                window.console.log(m);            }        },        changeState = function (connection, expectedState, newState) {            if (expectedState === connection.state) {                connection.state = newState;                $(connection).triggerHandler(events.onStateChanged, [{ oldState: expectedState, newState: newState }]);                return true;            }            return false;        },        isDisconnecting = function (connection) {            return connection.state === signalR.connectionState.disconnected;        },        configureStopReconnectingTimeout = function (connection) {            var stopReconnectingTimeout,                onReconnectTimeout;            // Check if this connection has already been configured to stop reconnecting after a specified timeout.            // Without this check if a connection is stopped then started events will be bound multiple times.            if (!connection._.configuredStopReconnectingTimeout) {                onReconnectTimeout = function (connection) {                    connection.log("Couldn't reconnect within the configured timeout (" + connection.disconnectTimeout + "ms), disconnecting.");                    connection.stop(/* async */ false, /* notifyServer */ false);                };                connection.reconnecting(function () {                    var connection = this;                    // Guard against state changing in a previous user defined even handler                    if (connection.state === signalR.connectionState.reconnecting) {                        stopReconnectingTimeout = window.setTimeout(function () { onReconnectTimeout(connection); }, connection.disconnectTimeout);                    }                });                connection.stateChanged(function (data) {                    if (data.oldState === signalR.connectionState.reconnecting) {                        // Clear the pending reconnect timeout check                        window.clearTimeout(stopReconnectingTimeout);                    }                });                connection._.configuredStopReconnectingTimeout = true;            }        };    signalR = function (url, qs, logging) {        /// <summary>Creates a new SignalR connection for the given url</summary>        /// <param name="url" type="String">The URL of the long polling endpoint</param>        /// <param name="qs" type="Object">        ///     [Optional] Custom querystring parameters to add to the connection URL.        ///     If an object, every non-function member will be added to the querystring.        ///     If a string, it's added to the QS as specified.        /// </param>        /// <param name="logging" type="Boolean">        ///     [Optional] A flag indicating whether connection logging is enabled to the browser        ///     console/log. Defaults to false.        /// </param>        return new signalR.fn.init(url, qs, logging);    };    signalR._ = {        defaultContentType: "application/x-www-form-urlencoded; charset=UTF-8",        ieVersion: (function () {            var version,                matches;            if (window.navigator.appName === 'Microsoft Internet Explorer') {                // Check if the user agent has the pattern "MSIE (one or more numbers).(one or more numbers)";                matches = /MSIE ([0-9]+\.[0-9]+)/.exec(window.navigator.userAgent);                if (matches) {                    version = window.parseFloat(matches[1]);                }            }            // undefined value means not IE            return version;        })(),        error: function (message, source, context) {            var e = new Error(message);            e.source = source;            if (typeof context !== "undefined") {                e.context = context;            }            return e;        },        transportError: function (message, transport, source, context) {            var e = this.error(message, source, context);            e.transport = transport ? transport.name : undefined;            return e;        },        format: function () {            /// <summary>Usage: format("Hi {0}, you are {1}!", "Foo", 100) </summary>            var s = arguments[0];            for (var i = 0; i < arguments.length - 1; i++) {                s = s.replace("{" + i + "}", arguments[i + 1]);            }            return s;        },        firefoxMajorVersion: function (userAgent) {            // Firefox user agents: http://useragentstring.com/pages/Firefox/            var matches = userAgent.match(/Firefox\/(\d+)/);            if (!matches || !matches.length || matches.length < 2) {                return 0;            }            return parseInt(matches[1], 10 /* radix */);        },        configurePingInterval: function (connection) {            var config = connection._.config,                onFail = function (error) {                    $(connection).triggerHandler(events.onError, [error]);                };            if (config && !connection._.pingIntervalId && config.pingInterval) {                connection._.pingIntervalId = window.setInterval(function () {                    signalR.transports._logic.pingServer(connection).fail(onFail);                }, config.pingInterval);            }        }    };    signalR.events = events;    signalR.resources = resources;    signalR.ajaxDefaults = ajaxDefaults;    signalR.changeState = changeState;    signalR.isDisconnecting = isDisconnecting;    signalR.connectionState = {        connecting: 0,        connected: 1,        reconnecting: 2,        disconnected: 4    };    signalR.hub = {        start: function () {            // This will get replaced with the real hub connection start method when hubs is referenced correctly            throw new Error("SignalR: Error loading hubs. Ensure your hubs reference is correct, e.g. <script src='/signalr/js'></script>.");        }    };    _pageWindow.load(function () { _pageLoaded = true; });    function validateTransport(requestedTransport, connection) {        /// <summary>Validates the requested transport by cross checking it with the pre-defined signalR.transports</summary>        /// <param name="requestedTransport" type="Object">The designated transports that the user has specified.</param>        /// <param name="connection" type="signalR">The connection that will be using the requested transports.  Used for logging purposes.</param>        /// <returns type="Object" />        if ($.isArray(requestedTransport)) {            // Go through transport array and remove an "invalid" tranports            for (var i = requestedTransport.length - 1; i >= 0; i--) {                var transport = requestedTransport[i];                if ($.type(transport) !== "string" || !signalR.transports[transport]) {                    connection.log("Invalid transport: " + transport + ", removing it from the transports list.");                    requestedTransport.splice(i, 1);                }            }            // Verify we still have transports left, if we dont then we have invalid transports            if (requestedTransport.length === 0) {                connection.log("No transports remain within the specified transport array.");                requestedTransport = null;            }        } else if (!signalR.transports[requestedTransport] && requestedTransport !== "auto") {            connection.log("Invalid transport: " + requestedTransport.toString() + ".");            requestedTransport = null;        } else if (requestedTransport === "auto" && signalR._.ieVersion <= 8) {            // If we're doing an auto transport and we're IE8 then force longPolling, #1764            return ["longPolling"];        }        return requestedTransport;    }    function getDefaultPort(protocol) {        if (protocol === "http:") {            return 80;        } else if (protocol === "https:") {            return 443;        }    }    function addDefaultPort(protocol, url) {        // Remove ports  from url.  We have to check if there's a / or end of line        // following the port in order to avoid removing ports such as 8080.        if (url.match(/:\d+$/)) {            return url;        } else {            return url + ":" + getDefaultPort(protocol);        }    }    function ConnectingMessageBuffer(connection, drainCallback) {        var that = this,            buffer = [];        that.tryBuffer = function (message) {            if (connection.state === $.signalR.connectionState.connecting) {                buffer.push(message);                return true;            }            return false;        };        that.drain = function () {            // Ensure that the connection is connected when we drain (do not want to drain while a connection is not active)            if (connection.state === $.signalR.connectionState.connected) {                while (buffer.length > 0) {                    drainCallback(buffer.shift());                }            }        };        that.clear = function () {            buffer = [];        };    }    signalR.fn = signalR.prototype = {        init: function (url, qs, logging) {            var $connection = $(this);            this.url = url;            this.qs = qs;            this._ = {                keepAliveData: {},                connectingMessageBuffer: new ConnectingMessageBuffer(this, function (message) {                    $connection.triggerHandler(events.onReceived, [message]);                }),                onFailedTimeoutHandle: null,                lastMessageAt: new Date().getTime(),                lastActiveAt: new Date().getTime(),                beatInterval: 5000, // Default value, will only be overridden if keep alive is enabled,                beatHandle: null,                totalTransportConnectTimeout: 0 // This will be the sum of the TransportConnectTimeout sent in response to negotiate and connection.transportConnectTimeout            };            if (typeof (logging) === "boolean") {                this.logging = logging;            }        },        _parseResponse: function (response) {            var that = this;            if (!response) {                return response;            } else if (typeof response === "string") {                return that.json.parse(response);            } else {                return response;            }        },        json: window.JSON,        isCrossDomain: function (url, against) {            /// <summary>Checks if url is cross domain</summary>            /// <param name="url" type="String">The base URL</param>            /// <param name="against" type="Object">            ///     An optional argument to compare the URL against, if not specified it will be set to window.location.            ///     If specified it must contain a protocol and a host property.            /// </param>            var link;            url = $.trim(url);            against = against || window.location;            if (url.indexOf("http") !== 0) {                return false;            }            // Create an anchor tag.            link = window.document.createElement("a");            link.href = url;            // When checking for cross domain we have to special case port 80 because the window.location will remove the            return link.protocol + addDefaultPort(link.protocol, link.host) !== against.protocol + addDefaultPort(against.protocol, against.host);        },        ajaxDataType: "text",        contentType: "application/json; charset=UTF-8",        logging: false,        state: signalR.connectionState.disconnected,        clientProtocol: "1.3",        reconnectDelay: 2000,        transportConnectTimeout: 0,        disconnectTimeout: 30000, // This should be set by the server in response to the negotiate request (30s default)        reconnectWindow: 30000, // This should be set by the server in response to the negotiate request        keepAliveWarnAt: 2 / 3, // Warn user of slow connection if we breach the X% mark of the keep alive timeout        start: function (options, callback) {            /// <summary>Starts the connection</summary>            /// <param name="options" type="Object">Options map</param>            /// <param name="callback" type="Function">A callback function to execute when the connection has started</param>            var connection = this,                config = {                    pingInterval: 300000,                    waitForPageLoad: true,                    transport: "auto",                    jsonp: false                },                initialize,                deferred = connection._deferral || $.Deferred(), // Check to see if there is a pre-existing deferral that's being built on, if so we want to keep using it                parser = window.document.createElement("a");            // Persist the deferral so that if start is called multiple times the same deferral is used.            connection._deferral = deferred;            if (!connection.json) {                // no JSON!                throw new Error("SignalR: No JSON parser found. Please ensure json2.js is referenced before the SignalR.js file if you need to support clients without native JSON parsing support, e.g. IE<8.");            }            if ($.type(options) === "function") {                // Support calling with single callback parameter                callback = options;            } else if ($.type(options) === "object") {                $.extend(config, options);                if ($.type(config.callback) === "function") {                    callback = config.callback;                }            }            config.transport = validateTransport(config.transport, connection);            // If the transport is invalid throw an error and abort start            if (!config.transport) {                throw new Error("SignalR: Invalid transport(s) specified, aborting start.");            }            connection._.config = config;            // Check to see if start is being called prior to page load            // If waitForPageLoad is true we then want to re-direct function call to the window load event            if (!_pageLoaded && config.waitForPageLoad === true) {                connection._.deferredStartHandler = function () {                    connection.start(options, callback);                };                _pageWindow.bind("load", connection._.deferredStartHandler);                return deferred.promise();            }            // If we're already connecting just return the same deferral as the original connection start            if (connection.state === signalR.connectionState.connecting) {                return deferred.promise();            } else if (changeState(connection,                            signalR.connectionState.disconnected,                            signalR.connectionState.connecting) === false) {                // We're not connecting so try and transition into connecting.                // If we fail to transition then we're either in connected or reconnecting.                deferred.resolve(connection);                return deferred.promise();            }            configureStopReconnectingTimeout(connection);            // Resolve the full url            parser.href = connection.url;            if (!parser.protocol || parser.protocol === ":") {                connection.protocol = window.document.location.protocol;                connection.host = window.document.location.host;                connection.baseUrl = connection.protocol + "//" + connection.host;            } else {                connection.protocol = parser.protocol;                connection.host = parser.host;                connection.baseUrl = parser.protocol + "//" + parser.host;            }            // Set the websocket protocol            connection.wsProtocol = connection.protocol === "https:" ? "wss://" : "ws://";            // If jsonp with no/auto transport is specified, then set the transport to long polling            // since that is the only transport for which jsonp really makes sense.            // Some developers might actually choose to specify jsonp for same origin requests            // as demonstrated by Issue #623.            if (config.transport === "auto" && config.jsonp === true) {                config.transport = "longPolling";            }            // If the url is protocol relative, prepend the current windows protocol to the url.            if (connection.url.indexOf("//") === 0) {                connection.url = window.location.protocol + connection.url;                connection.log("Protocol relative URL detected, normalizing it to '" + connection.url + "'.");            }            if (this.isCrossDomain(connection.url)) {                connection.log("Auto detected cross domain url.");                if (config.transport === "auto") {                    // TODO: Support XDM with foreverFrame                    config.transport = ["webSockets", "serverSentEvents", "longPolling"];                }                if (typeof (config.withCredentials) === "undefined") {                    config.withCredentials = true;                }                // Determine if jsonp is the only choice for negotiation, ajaxSend and ajaxAbort.                // i.e. if the browser doesn't supports CORS                // If it is, ignore any preference to the contrary, and switch to jsonp.                if (!config.jsonp) {                    config.jsonp = !$.support.cors;                    if (config.jsonp) {                        connection.log("Using jsonp because this browser doesn't support CORS.");                    }                }                connection.contentType = signalR._.defaultContentType;            }            connection.withCredentials = config.withCredentials;            connection.ajaxDataType = config.jsonp ? "jsonp" : "text";            $(connection).bind(events.onStart, function (e, data) {                if ($.type(callback) === "function") {                    callback.call(connection);                }                deferred.resolve(connection);            });            initialize = function (transports, index) {                var noTransportError = signalR._.error(resources.noTransportOnInit);                index = index || 0;                if (index >= transports.length) {                    // No transport initialized successfully                    $(connection).triggerHandler(events.onError, [noTransportError]);                    deferred.reject(noTransportError);                    // Stop the connection if it has connected and move it into the disconnected state                    connection.stop();                    return;                }                // The connection was aborted                if (connection.state === signalR.connectionState.disconnected) {                    return;                }                var transportName = transports[index],                    transport = signalR.transports[transportName],                    initializationComplete = false,                    onFailed = function () {                        // Check if we've already triggered onFailed, onStart                        if (!initializationComplete) {                            initializationComplete = true;                            window.clearTimeout(connection._.onFailedTimeoutHandle);                            transport.stop(connection);                            initialize(transports, index + 1);                        }                    };                connection.transport = transport;                try {                    connection._.onFailedTimeoutHandle = window.setTimeout(function () {                        connection.log(transport.name + " timed out when trying to connect.");                        onFailed();                    }, connection._.totalTransportConnectTimeout);                    transport.start(connection, function () { // success                        // Firefox 11+ doesn't allow sync XHR withCredentials: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#withCredentials                        var isFirefox11OrGreater = signalR._.firefoxMajorVersion(window.navigator.userAgent) >= 11,                            asyncAbort = !!connection.withCredentials && isFirefox11OrGreater;                        // The connection was aborted while initializing transports                        if (connection.state === signalR.connectionState.disconnected) {                            return;                        }                        if (!initializationComplete) {                            initializationComplete = true;                            window.clearTimeout(connection._.onFailedTimeoutHandle);                            if (transport.supportsKeepAlive && connection._.keepAliveData.activated) {                                signalR.transports._logic.monitorKeepAlive(connection);                            }                            signalR.transports._logic.startHeartbeat(connection);                            // Used to ensure low activity clients maintain their authentication.                            // Must be configured once a transport has been decided to perform valid ping requests.                            signalR._.configurePingInterval(connection);                            changeState(connection,                                        signalR.connectionState.connecting,                                        signalR.connectionState.connected);                            // Drain any incoming buffered messages (messages that came in prior to connect)                            connection._.connectingMessageBuffer.drain();                            $(connection).triggerHandler(events.onStart);                            // wire the stop handler for when the user leaves the page                            _pageWindow.bind("unload", function () {                                connection.log("Window unloading, stopping the connection.");                                connection.stop(asyncAbort);                            });                            if (isFirefox11OrGreater) {                                // Firefox does not fire cross-domain XHRs in the normal unload handler on tab close.                                // #2400                                _pageWindow.bind("beforeunload", function () {                                    // If connection.stop() runs runs in beforeunload and fails, it will also fail                                    // in unload unless connection.stop() runs after a timeout.                                    window.setTimeout(function () {                                        connection.stop(asyncAbort);                                    }, 0);                                });                            }                        }                    }, onFailed);                }                catch (error) {                    connection.log(transport.name + " transport threw '" + error.message + "' when attempting to start.");                    onFailed();                }            };            var url = connection.url + "/negotiate",                onFailed = function (error, connection) {                    var err = signalR._.error(resources.errorOnNegotiate, error, connection._.negotiateRequest);                    $(connection).triggerHandler(events.onError, err);                    deferred.reject(err);                    // Stop the connection if negotiate failed                    connection.stop();                };            $(connection).triggerHandler(events.onStarting);            url = signalR.transports._logic.prepareQueryString(connection, url);            // Add the client version to the negotiate request.  We utilize the same addQs method here            // so that it can append the clientVersion appropriately to the URL            url = signalR.transports._logic.addQs(url, {                clientProtocol: connection.clientProtocol            });            connection.log("Negotiating with '" + url + "'.");            // Save the ajax negotiate request object so we can abort it if stop is called while the request is in flight.            connection._.negotiateRequest = $.ajax(                $.extend({}, $.signalR.ajaxDefaults, {                    xhrFields: { withCredentials: connection.withCredentials },                    url: url,                    type: "GET",                    contentType: connection.contentType,                    data: {},                    dataType: connection.ajaxDataType,                    error: function (error, statusText) {                        // We don't want to cause any errors if we're aborting our own negotiate request.                        if (statusText !== _negotiateAbortText) {                            onFailed(error, connection);                        } else {                            // This rejection will noop if the deferred has already been resolved or rejected.                            deferred.reject(signalR._.error(resources.stoppedWhileNegotiating, null /* error */, connection._.negotiateRequest));                        }                    },                    success: function (result) {                        var res,                            keepAliveData,                            protocolError,                            transports = [],                            supportedTransports = [];                        try {                            res = connection._parseResponse(result);                        } catch (error) {                            onFailed(signalR._.error(resources.errorParsingNegotiateResponse, error), connection);                            return;                        }                        keepAliveData = connection._.keepAliveData;                        connection.appRelativeUrl = res.Url;                        connection.id = res.ConnectionId;                        connection.token = res.ConnectionToken;                        connection.webSocketServerUrl = res.WebSocketServerUrl;                        // Once the server has labeled the PersistentConnection as Disconnected, we should stop attempting to reconnect                        // after res.DisconnectTimeout seconds.                        connection.disconnectTimeout = res.DisconnectTimeout * 1000; // in ms                        // Add the TransportConnectTimeout from the response to the transportConnectTimeout from the client to calculate the total timeout                        connection._.totalTransportConnectTimeout = connection.transportConnectTimeout + res.TransportConnectTimeout * 1000;                        // If we have a keep alive                        if (res.KeepAliveTimeout) {                            // Register the keep alive data as activated                            keepAliveData.activated = true;                            // Timeout to designate when to force the connection into reconnecting converted to milliseconds                            keepAliveData.timeout = res.KeepAliveTimeout * 1000;                            // Timeout to designate when to warn the developer that the connection may be dead or is not responding.                            keepAliveData.timeoutWarning = keepAliveData.timeout * connection.keepAliveWarnAt;                            // Instantiate the frequency in which we check the keep alive.  It must be short in order to not miss/pick up any changes                            connection._.beatInterval = (keepAliveData.timeout - keepAliveData.timeoutWarning) / 3;                        } else {                            keepAliveData.activated = false;                        }                        connection.reconnectWindow = connection.disconnectTimeout + (keepAliveData.timeout || 0);                        if (!res.ProtocolVersion || res.ProtocolVersion !== connection.clientProtocol) {                            protocolError = signalR._.error(signalR._.format(resources.protocolIncompatible, connection.clientProtocol, res.ProtocolVersion));                            $(connection).triggerHandler(events.onError, [protocolError]);                            deferred.reject(protocolError);                            return;                        }                        $.each(signalR.transports, function (key) {                            if ((key.indexOf("_") === 0) || (key === "webSockets" && !res.TryWebSockets)) {                                return true;                            }                            supportedTransports.push(key);                        });                        if ($.isArray(config.transport)) {                            $.each(config.transport, function (_, transport) {                                if ($.inArray(transport, supportedTransports) >= 0) {                                    transports.push(transport);                                }                            });                        } else if (config.transport === "auto") {                            transports = supportedTransports;                        } else if ($.inArray(config.transport, supportedTransports) >= 0) {                            transports.push(config.transport);                        }                        initialize(transports);                    }                }            ));            return deferred.promise();        },        starting: function (callback) {            /// <summary>Adds a callback that will be invoked before anything is sent over the connection</summary>            /// <param name="callback" type="Function">A callback function to execute before the connection is fully instantiated.</param>            /// <returns type="signalR" />            var connection = this;            $(connection).bind(events.onStarting, function (e, data) {                callback.call(connection);            });            return connection;        },        send: function (data) {            /// <summary>Sends data over the connection</summary>            /// <param name="data" type="String">The data to send over the connection</param>            /// <returns type="signalR" />            var connection = this;            if (connection.state === signalR.connectionState.disconnected) {                // Connection hasn't been started yet                throw new Error("SignalR: Connection must be started before data can be sent. Call .start() before .send()");            }            if (connection.state === signalR.connectionState.connecting) {                // Connection hasn't been started yet                throw new Error("SignalR: Connection has not been fully initialized. Use .start().done() or .start().fail() to run logic after the connection has started.");            }            connection.transport.send(connection, data);            // REVIEW: Should we return deferred here?            return connection;        },        received: function (callback) {            /// <summary>Adds a callback that will be invoked after anything is received over the connection</summary>            /// <param name="callback" type="Function">A callback function to execute when any data is received on the connection</param>            /// <returns type="signalR" />            var connection = this;            $(connection).bind(events.onReceived, function (e, data) {                callback.call(connection, data);            });            return connection;        },        stateChanged: function (callback) {            /// <summary>Adds a callback that will be invoked when the connection state changes</summary>            /// <param name="callback" type="Function">A callback function to execute when the connection state changes</param>            /// <returns type="signalR" />            var connection = this;            $(connection).bind(events.onStateChanged, function (e, data) {                callback.call(connection, data);            });            return connection;        },        error: function (callback) {            /// <summary>Adds a callback that will be invoked after an error occurs with the connection</summary>            /// <param name="callback" type="Function">A callback function to execute when an error occurs on the connection</param>            /// <returns type="signalR" />            var connection = this;            $(connection).bind(events.onError, function (e, errorData, sendData) {                // In practice 'errorData' is the SignalR built error object.                // In practice 'sendData' is undefined for all error events except those triggered by                // 'ajaxSend' and 'webSockets.send'.'sendData' is the original send payload.                callback.call(connection, errorData, sendData);            });            return connection;        },        disconnected: function (callback) {            /// <summary>Adds a callback that will be invoked when the client disconnects</summary>            /// <param name="callback" type="Function">A callback function to execute when the connection is broken</param>            /// <returns type="signalR" />            var connection = this;            $(connection).bind(events.onDisconnect, function (e, data) {                callback.call(connection);            });            return connection;        },        connectionSlow: function (callback) {            /// <summary>Adds a callback that will be invoked when the client detects a slow connection</summary>            /// <param name="callback" type="Function">A callback function to execute when the connection is slow</param>            /// <returns type="signalR" />            var connection = this;            $(connection).bind(events.onConnectionSlow, function (e, data) {                callback.call(connection);            });            return connection;        },        reconnecting: function (callback) {            /// <summary>Adds a callback that will be invoked when the underlying transport begins reconnecting</summary>            /// <param name="callback" type="Function">A callback function to execute when the connection enters a reconnecting state</param>            /// <returns type="signalR" />            var connection = this;            $(connection).bind(events.onReconnecting, function (e, data) {                callback.call(connection);            });            return connection;        },        reconnected: function (callback) {            /// <summary>Adds a callback that will be invoked when the underlying transport reconnects</summary>            /// <param name="callback" type="Function">A callback function to execute when the connection is restored</param>            /// <returns type="signalR" />            var connection = this;            $(connection).bind(events.onReconnect, function (e, data) {                callback.call(connection);            });            return connection;        },        stop: function (async, notifyServer) {            /// <summary>Stops listening</summary>            /// <param name="async" type="Boolean">Whether or not to asynchronously abort the connection</param>            /// <param name="notifyServer" type="Boolean">Whether we want to notify the server that we are aborting the connection</param>            /// <returns type="signalR" />            var connection = this,                // Save deferral because this is always cleaned up                deferral = connection._deferral;            // Verify that we've bound a load event.            if (connection._.deferredStartHandler) {                // Unbind the event.                _pageWindow.unbind("load", connection._.deferredStartHandler);            }            // Always clean up private non-timeout based state.            delete connection._deferral;            delete connection._.config;            delete connection._.deferredStartHandler;            // This needs to be checked despite the connection state because a connection start can be deferred until page load.            // If we've deferred the start due to a page load we need to unbind the "onLoad" -> start event.            if (!_pageLoaded && (!connection._.config || connection._.config.waitForPageLoad === true)) {                connection.log("Stopping connection prior to negotiate.");                // If we have a deferral we should reject it                if (deferral) {                    deferral.reject(signalR._.error(resources.stoppedWhileLoading));                }                // Short-circuit because the start has not been fully started.                return;            }            if (connection.state === signalR.connectionState.disconnected) {                return;            }            connection.log("Stopping connection.");            changeState(connection, connection.state, signalR.connectionState.disconnected);            // Clear this no matter what            window.clearTimeout(connection._.beatHandle);            window.clearTimeout(connection._.onFailedTimeoutHandle);            window.clearInterval(connection._.pingIntervalId);            if (connection.transport) {                connection.transport.stop(connection);                if (notifyServer !== false) {                    connection.transport.abort(connection, async);                }                if (connection.transport.supportsKeepAlive && connection._.keepAliveData.activated) {                    signalR.transports._logic.stopMonitoringKeepAlive(connection);                }                connection.transport = null;            }            if (connection._.negotiateRequest) {                // If the negotiation request has already completed this will noop.                connection._.negotiateRequest.abort(_negotiateAbortText);                delete connection._.negotiateRequest;            }            // Trigger the disconnect event            $(connection).triggerHandler(events.onDisconnect);            delete connection.messageId;            delete connection.groupsToken;            delete connection.id;            delete connection._.pingIntervalId;            delete connection._.lastMessageAt;            delete connection._.lastActiveAt;            // Clear out our message buffer            connection._.connectingMessageBuffer.clear();            return connection;        },        log: function (msg) {            log(msg, this.logging);        }    };    signalR.fn.init.prototype = signalR.fn;    signalR.noConflict = function () {        /// <summary>Reinstates the original value of $.connection and returns the signalR object for manual assignment</summary>        /// <returns type="signalR" />        if ($.connection === signalR) {            $.connection = _connection;        }        return signalR;    };    if ($.connection) {        _connection = $.connection;    }    $.connection = $.signalR = signalR;}(window.jQuery, window));/* jquery.signalR.transports.common.js */// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.md in the project root for license information./*global window:false *//// <reference path="jquery.signalR.core.js" />(function ($, window, undefined) {    "use strict";    var signalR = $.signalR,        events = $.signalR.events,        changeState = $.signalR.changeState,        transportLogic;    signalR.transports = {};    function beat(connection) {        if (connection._.keepAliveData.monitoring) {            checkIfAlive(connection);        }        // Ensure that we successfully marked active before continuing the heartbeat.        if (transportLogic.markActive(connection)) {            connection._.beatHandle = window.setTimeout(function () {                beat(connection);            }, connection._.beatInterval);        }    }    function checkIfAlive(connection) {        var keepAliveData = connection._.keepAliveData,            timeElapsed;        // Only check if we're connected        if (connection.state === signalR.connectionState.connected) {            timeElapsed = new Date().getTime() - connection._.lastMessageAt;            // Check if the keep alive has completely timed out            if (timeElapsed >= keepAliveData.timeout) {                connection.log("Keep alive timed out.  Notifying transport that connection has been lost.");                // Notify transport that the connection has been lost                connection.transport.lostConnection(connection);            } else if (timeElapsed >= keepAliveData.timeoutWarning) {                // This is to assure that the user only gets a single warning                if (!keepAliveData.userNotified) {                    connection.log("Keep alive has been missed, connection may be dead/slow.");                    $(connection).triggerHandler(events.onConnectionSlow);                    keepAliveData.userNotified = true;                }            } else {                keepAliveData.userNotified = false;            }        }    }    function addConnectionData(url, connectionData) {        var appender = url.indexOf("?") !== -1 ? "&" : "?";        if (connectionData) {            url += appender + "connectionData=" + window.encodeURIComponent(connectionData);        }        return url;    }    transportLogic = signalR.transports._logic = {        pingServer: function (connection) {            /// <summary>Pings the server</summary>            /// <param name="connection" type="signalr">Connection associated with the server ping</param>            /// <returns type="signalR" />            var url, deferral = $.Deferred(), xhr;            if (connection.transport) {                url = connection.url + "/ping";                url = transportLogic.addQs(url, connection.qs);                xhr = $.ajax(                    $.extend({}, $.signalR.ajaxDefaults, {                        xhrFields: { withCredentials: connection.withCredentials },                        url: url,                        type: "GET",                        contentType: connection.contentType,                        data: {},                        dataType: connection.ajaxDataType,                        success: function (result) {                            var data;                            try {                                data = connection._parseResponse(result);                            }                            catch (error) {                                deferral.reject(                                    signalR._.transportError(                                        signalR.resources.pingServerFailedParse,                                        connection.transport,                                        error,                                        xhr                                    )                                );                                connection.stop();                                return;                            }                            if (data.Response === "pong") {                                deferral.resolve();                            }                            else {                                deferral.reject(                                    signalR._.transportError(                                        signalR._.format(signalR.resources.pingServerFailedInvalidResponse, result.responseText),                                        connection.transport,                                        null /* error */,                                        xhr                                    )                                );                            }                        },                        error: function (error) {                            if (error.status === 401 || error.status === 403) {                                deferral.reject(                                    signalR._.transportError(                                        signalR._.format(signalR.resources.pingServerFailedStatusCode, error.status),                                        connection.transport,                                        error,                                        xhr                                    )                                );                                connection.stop();                            }                            else {                                deferral.reject(                                    signalR._.transportError(                                        signalR.resources.pingServerFailed,                                        connection.transport,                                        error,                                        xhr                                    )                                );                            }                        }                    }                ));            }            else {                deferral.reject(                    signalR._.transportError(                        signalR.resources.noConnectionTransport,                        connection.transport                    )                );            }            return deferral.promise();        },        prepareQueryString: function (connection, url) {            url = transportLogic.addQs(url, connection.qs);            return addConnectionData(url, connection.data);        },        addQs: function (url, qs) {            var appender = url.indexOf("?") !== -1 ? "&" : "?",                firstChar;            if (!qs) {                return url;            }            if (typeof (qs) === "object") {                return url + appender + $.param(qs);            }            if (typeof (qs) === "string") {                firstChar = qs.charAt(0);                if (firstChar === "?" || firstChar === "&") {                    appender = "";                }                return url + appender + qs;            }            throw new Error("Query string property must be either a string or object.");        },        getUrl: function (connection, transport, reconnecting, poll) {            /// <summary>Gets the url for making a GET based connect request</summary>            var baseUrl = transport === "webSockets" ? "" : connection.baseUrl,                url = baseUrl + connection.appRelativeUrl,                qs = "transport=" + transport + "&connectionToken=" + window.encodeURIComponent(connection.token);            if (connection.groupsToken) {                qs += "&groupsToken=" + window.encodeURIComponent(connection.groupsToken);            }            if (!reconnecting) {                url += "/connect";            } else {                if (poll) {                    // longPolling transport specific                    url += "/poll";                } else {                    url += "/reconnect";                }                if (connection.messageId) {                    qs += "&messageId=" + window.encodeURIComponent(connection.messageId);                }            }            url += "?" + qs;            url = transportLogic.prepareQueryString(connection, url);            url += "&tid=" + Math.floor(Math.random() * 11);            return url;        },        maximizePersistentResponse: function (minPersistentResponse) {            return {                MessageId: minPersistentResponse.C,                Messages: minPersistentResponse.M,                Initialized: typeof (minPersistentResponse.S) !== "undefined" ? true : false,                Disconnect: typeof (minPersistentResponse.D) !== "undefined" ? true : false,                ShouldReconnect: typeof (minPersistentResponse.T) !== "undefined" ? true : false,                LongPollDelay: minPersistentResponse.L,                GroupsToken: minPersistentResponse.G            };        },        updateGroups: function (connection, groupsToken) {            if (groupsToken) {                connection.groupsToken = groupsToken;            }        },        stringifySend: function (connection, message) {            if (typeof (message) === "string" || typeof (message) === "undefined" || message === null) {                return message;            }            return connection.json.stringify(message);        },        ajaxSend: function (connection, data) {            var payload = transportLogic.stringifySend(connection, data),                url = connection.url + "/send" + "?transport=" + connection.transport.name + "&connectionToken=" + window.encodeURIComponent(connection.token),                xhr,                onFail = function (error, connection) {                    $(connection).triggerHandler(events.onError, [signalR._.transportError(signalR.resources.sendFailed, connection.transport, error, xhr), data]);                };            url = transportLogic.prepareQueryString(connection, url);            xhr = $.ajax(                $.extend({}, $.signalR.ajaxDefaults, {                    xhrFields: { withCredentials: connection.withCredentials },                    url: url,                    type: connection.ajaxDataType === "jsonp" ? "GET" : "POST",                    contentType: signalR._.defaultContentType,                    dataType: connection.ajaxDataType,                    data: {                        data: payload                    },                    success: function (result) {                        var res;                        if (result) {                            try {                                res = connection._parseResponse(result);                            }                            catch (error) {                                onFail(error, connection);                                connection.stop();                                return;                            }                            transportLogic.triggerReceived(connection, res);                        }                    },                    error: function (error, textStatus) {                        if (textStatus === "abort" || textStatus === "parsererror") {                            // The parsererror happens for sends that don't return any data, and hence                            // don't write the jsonp callback to the response. This is harder to fix on the server                            // so just hack around it on the client for now.                            return;                        }                        onFail(error, connection);                    }                }            ));            return xhr;        },        ajaxAbort: function (connection, async) {            if (typeof (connection.transport) === "undefined") {                return;            }            // Async by default unless explicitly overidden            async = typeof async === "undefined" ? true : async;            var url = connection.url + "/abort" + "?transport=" + connection.transport.name + "&connectionToken=" + window.encodeURIComponent(connection.token);            url = transportLogic.prepareQueryString(connection, url);            $.ajax(                $.extend({}, $.signalR.ajaxDefaults, {                    xhrFields: { withCredentials: connection.withCredentials },                    url: url,                    async: async,                    timeout: 1000,                    type: "POST",                    contentType: connection.contentType,                    dataType: connection.ajaxDataType,                    data: {}                }            ));            connection.log("Fired ajax abort async = " + async + ".");        },        tryInitialize: function (persistentResponse, onInitialized) {            if (persistentResponse.Initialized) {                onInitialized();            }        },        triggerReceived: function (connection, data) {            if (!connection._.connectingMessageBuffer.tryBuffer(data)) {                $(connection).triggerHandler(events.onReceived, [data]);            }        },        processMessages: function (connection, minData, onInitialized) {            var data;            // Update the last message time stamp            transportLogic.markLastMessage(connection);            if (minData) {                data = transportLogic.maximizePersistentResponse(minData);                if (data.Disconnect) {                    connection.log("Disconnect command received from server.");                    // Disconnected by the server                    connection.stop(false, false);                    return;                }                transportLogic.updateGroups(connection, data.GroupsToken);                if (data.MessageId) {                    connection.messageId = data.MessageId;                }                if (data.Messages) {                    $.each(data.Messages, function (index, message) {                        transportLogic.triggerReceived(connection, message);                    });                    transportLogic.tryInitialize(data, onInitialized);                }            }        },        monitorKeepAlive: function (connection) {            var keepAliveData = connection._.keepAliveData;            // If we haven't initiated the keep alive timeouts then we need to            if (!keepAliveData.monitoring) {                keepAliveData.monitoring = true;                transportLogic.markLastMessage(connection);                // Save the function so we can unbind it on stop                connection._.keepAliveData.reconnectKeepAliveUpdate = function () {                    // Mark a new message so that keep alive doesn't time out connections                    transportLogic.markLastMessage(connection);                };                // Update Keep alive on reconnect                $(connection).bind(events.onReconnect, connection._.keepAliveData.reconnectKeepAliveUpdate);                connection.log("Now monitoring keep alive with a warning timeout of " + keepAliveData.timeoutWarning + " and a connection lost timeout of " + keepAliveData.timeout + ".");            } else {                connection.log("Tried to monitor keep alive but it's already being monitored.");            }        },        stopMonitoringKeepAlive: function (connection) {            var keepAliveData = connection._.keepAliveData;            // Only attempt to stop the keep alive monitoring if its being monitored            if (keepAliveData.monitoring) {                // Stop monitoring                keepAliveData.monitoring = false;                // Remove the updateKeepAlive function from the reconnect event                $(connection).unbind(events.onReconnect, connection._.keepAliveData.reconnectKeepAliveUpdate);                // Clear all the keep alive data                connection._.keepAliveData = {};                connection.log("Stopping the monitoring of the keep alive.");            }        },        startHeartbeat: function (connection) {            connection._.lastActiveAt = new Date().getTime();            beat(connection);        },        markLastMessage: function (connection) {            connection._.lastMessageAt = new Date().getTime();        },        markActive: function (connection) {            if (transportLogic.verifyLastActive(connection)) {                connection._.lastActiveAt = new Date().getTime();                return true;            }            return false;        },        isConnectedOrReconnecting: function (connection) {            return connection.state === signalR.connectionState.connected ||                   connection.state === signalR.connectionState.reconnecting;        },        ensureReconnectingState: function (connection) {            if (changeState(connection,                        signalR.connectionState.connected,                        signalR.connectionState.reconnecting) === true) {                $(connection).triggerHandler(events.onReconnecting);            }            return connection.state === signalR.connectionState.reconnecting;        },        clearReconnectTimeout: function (connection) {            if (connection && connection._.reconnectTimeout) {                window.clearTimeout(connection._.reconnectTimeout);                delete connection._.reconnectTimeout;            }        },        verifyLastActive: function (connection) {            if (new Date().getTime() - connection._.lastActiveAt >= connection.reconnectWindow) {                connection.log("There has not been an active server connection for an extended period of time. Stopping connection.");                connection.stop();                return false;            }            return true;        },        reconnect: function (connection, transportName) {            var transport = signalR.transports[transportName];            // We should only set a reconnectTimeout if we are currently connected            // and a reconnectTimeout isn't already set.            if (transportLogic.isConnectedOrReconnecting(connection) && !connection._.reconnectTimeout) {                // Need to verify before the setTimeout occurs because an application sleep could occur during the setTimeout duration.                if (!transportLogic.verifyLastActive(connection)) {                    return;                }                connection._.reconnectTimeout = window.setTimeout(function () {                    if (!transportLogic.verifyLastActive(connection)) {                        return;                    }                    transport.stop(connection);                    if (transportLogic.ensureReconnectingState(connection)) {                        connection.log(transportName + " reconnecting.");                        transport.start(connection);                    }                }, connection.reconnectDelay);            }        },        handleParseFailure: function (connection, result, error, onFailed, context) {            // If we're in the initialization phase trigger onFailed, otherwise stop the connection.            if (connection.state === signalR.connectionState.connecting) {                connection.log("Failed to parse server response while attempting to connect.");                onFailed();            } else {                $(connection).triggerHandler(events.onError, [                    signalR._.transportError(                        signalR._.format(signalR.resources.parseFailed, result),                        connection.transport,                        error,                        context)]);                connection.stop();            }        },        foreverFrame: {            count: 0,            connections: {}        }    };}(window.jQuery, window));/* jquery.signalR.transports.webSockets.js */// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.md in the project root for license information./*global window:false *//// <reference path="jquery.signalR.transports.common.js" />(function ($, window, undefined) {    "use strict";    var signalR = $.signalR,        events = $.signalR.events,        changeState = $.signalR.changeState,        transportLogic = signalR.transports._logic;    signalR.transports.webSockets = {        name: "webSockets",        supportsKeepAlive: true,        send: function (connection, data) {            var payload = transportLogic.stringifySend(connection, data);            try {                connection.socket.send(payload);            } catch (ex) {                $(connection).triggerHandler(events.onError,                    [signalR._.transportError(                        signalR.resources.webSocketsInvalidState,                        connection.transport,                        ex,                        connection.socket                    ),                    data]);            }        },        start: function (connection, onSuccess, onFailed) {            var url,                opened = false,                that = this,                reconnecting = !onSuccess,                $connection = $(connection);            if (!window.WebSocket) {                onFailed();                return;            }            if (!connection.socket) {                if (connection.webSocketServerUrl) {                    url = connection.webSocketServerUrl;                } else {                    url = connection.wsProtocol + connection.host;                }                url += transportLogic.getUrl(connection, this.name, reconnecting);                connection.log("Connecting to websocket endpoint '" + url + "'.");                connection.socket = new window.WebSocket(url);                connection.socket.onopen = function () {                    opened = true;                    connection.log("Websocket opened.");                    transportLogic.clearReconnectTimeout(connection);                    if (changeState(connection,                                    signalR.connectionState.reconnecting,                                    signalR.connectionState.connected) === true) {                        $connection.triggerHandler(events.onReconnect);                    }                };                connection.socket.onclose = function (event) {                    // Only handle a socket close if the close is from the current socket.                    // Sometimes on disconnect the server will push down an onclose event                    // to an expired socket.                    if (this === connection.socket) {                        if (!opened) {                            if (onFailed) {                                onFailed();                            } else if (reconnecting) {                                that.reconnect(connection);                            }                            return;                        } else if (typeof event.wasClean !== "undefined" && event.wasClean === false) {                            // Ideally this would use the websocket.onerror handler (rather than checking wasClean in onclose) but                            // I found in some circumstances Chrome won't call onerror. This implementation seems to work on all browsers.                            $(connection).triggerHandler(events.onError, [signalR._.transportError(                                signalR.resources.webSocketClosed,                                connection.transport,                                event)]);                            connection.log("Unclean disconnect from websocket: " + event.reason || "[no reason given].");                        } else {                            connection.log("Websocket closed.");                        }                        that.reconnect(connection);                    }                };                connection.socket.onmessage = function (event) {                    var data;                    try {                        data = connection._parseResponse(event.data);                    }                    catch (error) {                        transportLogic.handleParseFailure(connection, event.data, error, onFailed, event);                        return;                    }                    if (data) {                        // data.M is PersistentResponse.Messages                        if ($.isEmptyObject(data) || data.M) {                            transportLogic.processMessages(connection, data, onSuccess);                        } else {                            // For websockets we need to trigger onReceived                            // for callbacks to outgoing hub calls.                            transportLogic.triggerReceived(connection, data);                        }                    }                };            }        },        reconnect: function (connection) {            transportLogic.reconnect(connection, this.name);        },        lostConnection: function (connection) {            this.reconnect(connection);        },        stop: function (connection) {            // Don't trigger a reconnect after stopping            transportLogic.clearReconnectTimeout(connection);            if (connection.socket) {                connection.log("Closing the Websocket.");                connection.socket.close();                connection.socket = null;            }        },        abort: function (connection, async) {            transportLogic.ajaxAbort(connection, async);        }    };}(window.jQuery, window));/* jquery.signalR.transports.serverSentEvents.js */// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.md in the project root for license information./*global window:false *//// <reference path="jquery.signalR.transports.common.js" />(function ($, window, undefined) {    "use strict";    var signalR = $.signalR,        events = $.signalR.events,        changeState = $.signalR.changeState,        transportLogic = signalR.transports._logic;    signalR.transports.serverSentEvents = {        name: "serverSentEvents",        supportsKeepAlive: true,        timeOut: 3000,        start: function (connection, onSuccess, onFailed) {            var that = this,                opened = false,                $connection = $(connection),                reconnecting = !onSuccess,                url,                reconnectTimeout;            if (connection.eventSource) {                connection.log("The connection already has an event source. Stopping it.");                connection.stop();            }            if (!window.EventSource) {                if (onFailed) {                    connection.log("This browser doesn't support SSE.");                    onFailed();                }                return;            }            url = transportLogic.getUrl(connection, this.name, reconnecting);            try {                connection.log("Attempting to connect to SSE endpoint '" + url + "'.");                connection.eventSource = new window.EventSource(url, { withCredentials: connection.withCredentials });            }            catch (e) {                connection.log("EventSource failed trying to connect with error " + e.Message + ".");                if (onFailed) {                    // The connection failed, call the failed callback                    onFailed();                } else {                    $connection.triggerHandler(events.onError, [signalR._.transportError(signalR.resources.eventSourceFailedToConnect, connection.transport, e)]);                    if (reconnecting) {                        // If we were reconnecting, rather than doing initial connect, then try reconnect again                        that.reconnect(connection);                    }                }                return;            }            if (reconnecting) {                reconnectTimeout = window.setTimeout(function () {                    if (opened === false) {                        // If we're reconnecting and the event source is attempting to connect,                        // don't keep retrying. This causes duplicate connections to spawn.                        if (connection.eventSource.readyState !== window.EventSource.OPEN) {                            // If we were reconnecting, rather than doing initial connect, then try reconnect again                            that.reconnect(connection);                        }                    }                },                that.timeOut);            }            connection.eventSource.addEventListener("open", function (e) {                connection.log("EventSource connected.");                if (reconnectTimeout) {                    window.clearTimeout(reconnectTimeout);                }                transportLogic.clearReconnectTimeout(connection);                if (opened === false) {                    opened = true;                    if (changeState(connection,                                         signalR.connectionState.reconnecting,                                         signalR.connectionState.connected) === true) {                        $connection.triggerHandler(events.onReconnect);                    }                }            }, false);            connection.eventSource.addEventListener("message", function (e) {                var res;                // process messages                if (e.data === "initialized") {                    return;                }                try {                    res = connection._parseResponse(e.data);                }                catch (error) {                    transportLogic.handleParseFailure(connection, e.data, error, onFailed, e);                    return;                }                transportLogic.processMessages(connection, res, onSuccess);            }, false);            connection.eventSource.addEventListener("error", function (e) {                // Only handle an error if the error is from the current Event Source.                // Sometimes on disconnect the server will push down an error event                // to an expired Event Source.                if (this !== connection.eventSource) {                    return;                }                if (!opened) {                    if (onFailed) {                        onFailed();                    }                    return;                }                connection.log("EventSource readyState: " + connection.eventSource.readyState + ".");                if (e.eventPhase === window.EventSource.CLOSED) {                    // We don't use the EventSource's native reconnect function as it                    // doesn't allow us to change the URL when reconnecting. We need                    // to change the URL to not include the /connect suffix, and pass                    // the last message id we received.                    connection.log("EventSource reconnecting due to the server connection ending.");                    that.reconnect(connection);                } else {                    // connection error                    connection.log("EventSource error.");                    $connection.triggerHandler(events.onError, [signalR._.transportError(signalR.resources.eventSourceError, connection.transport, e)]);                }            }, false);        },        reconnect: function (connection) {            transportLogic.reconnect(connection, this.name);        },        lostConnection: function (connection) {            this.reconnect(connection);        },        send: function (connection, data) {            transportLogic.ajaxSend(connection, data);        },        stop: function (connection) {            // Don't trigger a reconnect after stopping            transportLogic.clearReconnectTimeout(connection);            if (connection && connection.eventSource) {                connection.log("EventSource calling close().");                connection.eventSource.close();                connection.eventSource = null;                delete connection.eventSource;            }        },        abort: function (connection, async) {            transportLogic.ajaxAbort(connection, async);        }    };}(window.jQuery, window));/* jquery.signalR.transports.foreverFrame.js */// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.md in the project root for license information./*global window:false *//// <reference path="jquery.signalR.transports.common.js" />(function ($, window, undefined) {    "use strict";    var signalR = $.signalR,        events = $.signalR.events,        changeState = $.signalR.changeState,        transportLogic = signalR.transports._logic,        createFrame = function () {            var frame = window.document.createElement("iframe");            frame.setAttribute("style", "position:absolute;top:0;left:0;width:0;height:0;visibility:hidden;");            return frame;        },        // Used to prevent infinite loading icon spins in older versions of ie        // We build this object inside a closure so we don't pollute the rest of        // the foreverFrame transport with unnecessary functions/utilities.        loadPreventer = (function () {            var loadingFixIntervalId = null,                loadingFixInterval = 1000,                attachedTo = 0;            return {                prevent: function () {                    // Prevent additional iframe removal procedures from newer browsers                    if (signalR._.ieVersion <= 8) {                        // We only ever want to set the interval one time, so on the first attachedTo                        if (attachedTo === 0) {                            // Create and destroy iframe every 3 seconds to prevent loading icon, super hacky                            loadingFixIntervalId = window.setInterval(function () {                                var tempFrame = createFrame();                                window.document.body.appendChild(tempFrame);                                window.document.body.removeChild(tempFrame);                                tempFrame = null;                            }, loadingFixInterval);                        }                        attachedTo++;                    }                },                cancel: function () {                    // Only clear the interval if there's only one more object that the loadPreventer is attachedTo                    if (attachedTo === 1) {                        window.clearInterval(loadingFixIntervalId);                    }                    if (attachedTo > 0) {                        attachedTo--;                    }                }            };        })();    signalR.transports.foreverFrame = {        name: "foreverFrame",        supportsKeepAlive: true,        // Added as a value here so we can create tests to verify functionality        iframeClearThreshold: 50,        start: function (connection, onSuccess, onFailed) {            var that = this,                frameId = (transportLogic.foreverFrame.count += 1),                url,                frame = createFrame(),                frameLoadHandler = function () {                    connection.log("Forever frame iframe finished loading and is no longer receiving messages.");                    that.reconnect(connection);                };            if (window.EventSource) {                // If the browser supports SSE, don't use Forever Frame                if (onFailed) {                    connection.log("This browser supports SSE, skipping Forever Frame.");                    onFailed();                }                return;            }            frame.setAttribute("data-signalr-connection-id", connection.id);            // Start preventing loading icon            // This will only perform work if the loadPreventer is not attached to another connection.            loadPreventer.prevent();            // Build the url            url = transportLogic.getUrl(connection, this.name);            url += "&frameId=" + frameId;            // Set body prior to setting URL to avoid caching issues.            window.document.body.appendChild(frame);            connection.log("Binding to iframe's load event.");            if (frame.addEventListener) {                frame.addEventListener("load", frameLoadHandler, false);            } else if (frame.attachEvent) {                frame.attachEvent("onload", frameLoadHandler);            }            frame.src = url;            transportLogic.foreverFrame.connections[frameId] = connection;            connection.frame = frame;            connection.frameId = frameId;            if (onSuccess) {                connection.onSuccess = function () {                    connection.log("Iframe transport started.");                    onSuccess();                };            }        },        reconnect: function (connection) {            var that = this;            // Need to verify connection state and verify before the setTimeout occurs because an application sleep could occur during the setTimeout duration.            if (transportLogic.isConnectedOrReconnecting(connection) && transportLogic.verifyLastActive(connection)) {                window.setTimeout(function () {                    // Verify that we're ok to reconnect.                    if (!transportLogic.verifyLastActive(connection)) {                        return;                    }                    if (connection.frame && transportLogic.ensureReconnectingState(connection)) {                        var frame = connection.frame,                            src = transportLogic.getUrl(connection, that.name, true) + "&frameId=" + connection.frameId;                        connection.log("Updating iframe src to '" + src + "'.");                        frame.src = src;                    }                }, connection.reconnectDelay);            }        },        lostConnection: function (connection) {            this.reconnect(connection);        },        send: function (connection, data) {            transportLogic.ajaxSend(connection, data);        },        receive: function (connection, data) {            var cw,                body;            transportLogic.processMessages(connection, data, connection.onSuccess);            // Protect against connection stopping from a callback trigger within the processMessages above.            if (connection.state === $.signalR.connectionState.connected) {                // Delete the script & div elements                connection.frameMessageCount = (connection.frameMessageCount || 0) + 1;                if (connection.frameMessageCount > signalR.transports.foreverFrame.iframeClearThreshold) {                    connection.frameMessageCount = 0;                    cw = connection.frame.contentWindow || connection.frame.contentDocument;                    if (cw && cw.document && cw.document.body) {                        body = cw.document.body;                        // Remove all the child elements from the iframe's body to conserver memory                        while (body.firstChild) {                            body.removeChild(body.firstChild);                        }                    }                }            }        },        stop: function (connection) {            var cw = null;            // Stop attempting to prevent loading icon            loadPreventer.cancel();            if (connection.frame) {                if (connection.frame.stop) {                    connection.frame.stop();                } else {                    try {                        cw = connection.frame.contentWindow || connection.frame.contentDocument;                        if (cw.document && cw.document.execCommand) {                            cw.document.execCommand("Stop");                        }                    }                    catch (e) {                        connection.log("Error occured when stopping foreverFrame transport. Message = " + e.message + ".");                    }                }                // Ensure the iframe is where we left it                if (connection.frame.parentNode === window.document.body) {                    window.document.body.removeChild(connection.frame);                }                delete transportLogic.foreverFrame.connections[connection.frameId];                connection.frame = null;                connection.frameId = null;                delete connection.frame;                delete connection.frameId;                delete connection.onSuccess;                delete connection.frameMessageCount;                connection.log("Stopping forever frame.");            }        },        abort: function (connection, async) {            transportLogic.ajaxAbort(connection, async);        },        getConnection: function (id) {            return transportLogic.foreverFrame.connections[id];        },        started: function (connection) {            if (changeState(connection,                signalR.connectionState.reconnecting,                signalR.connectionState.connected) === true) {                // If there's no onSuccess handler we assume this is a reconnect                $(connection).triggerHandler(events.onReconnect);            }        }    };}(window.jQuery, window));/* jquery.signalR.transports.longPolling.js */// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.md in the project root for license information./*global window:false *//// <reference path="jquery.signalR.transports.common.js" />(function ($, window, undefined) {    "use strict";    var signalR = $.signalR,        events = $.signalR.events,        changeState = $.signalR.changeState,        isDisconnecting = $.signalR.isDisconnecting,        transportLogic = signalR.transports._logic;    signalR.transports.longPolling = {        name: "longPolling",        supportsKeepAlive: false,        reconnectDelay: 3000,        start: function (connection, onSuccess, onFailed) {            /// <summary>Starts the long polling connection</summary>            /// <param name="connection" type="signalR">The SignalR connection to start</param>            var that = this,                fireConnect = function () {                    fireConnect = $.noop;                    connection.log("LongPolling connected.");                    onSuccess();                    // Reset onFailed to null because it shouldn't be called again                    onFailed = null;                },                tryFailConnect = function () {                    if (onFailed) {                        onFailed();                        onFailed = null;                        connection.log("LongPolling failed to connect.");                        return true;                    }                    return false;                },                privateData = connection._,                reconnectErrors = 0,                fireReconnected = function (instance) {                    window.clearTimeout(privateData.reconnectTimeoutId);                    privateData.reconnectTimeoutId = null;                    if (changeState(instance,                                    signalR.connectionState.reconnecting,                                    signalR.connectionState.connected) === true) {                        // Successfully reconnected!                        instance.log("Raising the reconnect event");                        $(instance).triggerHandler(events.onReconnect);                    }                },                // 1 hour                maxFireReconnectedTimeout = 3600000;            if (connection.pollXhr) {                connection.log("Polling xhr requests already exists, aborting.");                connection.stop();            }            connection.messageId = null;            privateData.reconnectTimeoutId = null;            privateData.pollTimeoutId = window.setTimeout(function () {                (function poll(instance, raiseReconnect) {                    var messageId = instance.messageId,                        connect = (messageId === null),                        reconnecting = !connect,                        polling = !raiseReconnect,                        url = transportLogic.getUrl(instance, that.name, reconnecting, polling);                    // If we've disconnected during the time we've tried to re-instantiate the poll then stop.                    if (isDisconnecting(instance) === true) {                        return;                    }                    connection.log("Opening long polling request to '" + url + "'.");                    instance.pollXhr = $.ajax(                        $.extend({}, $.signalR.ajaxDefaults, {                            xhrFields: { withCredentials: connection.withCredentials },                            url: url,                            type: "GET",                            dataType: connection.ajaxDataType,                            contentType: connection.contentType,                            success: function (result) {                                var minData,                                    delay = 0,                                    data,                                    shouldReconnect;                                connection.log("Long poll complete.");                                // Reset our reconnect errors so if we transition into a reconnecting state again we trigger                                // reconnected quickly                                reconnectErrors = 0;                                try {                                    minData = connection._parseResponse(result);                                }                                catch (error) {                                    transportLogic.handleParseFailure(instance, result, error, tryFailConnect, instance.pollXhr);                                    return;                                }                                // If there's currently a timeout to trigger reconnect, fire it now before processing messages                                if (privateData.reconnectTimeoutId !== null) {                                    fireReconnected(instance);                                }                                if (minData) {                                    data = transportLogic.maximizePersistentResponse(minData);                                }                                transportLogic.processMessages(instance, minData, fireConnect);                                if (data &&                                    $.type(data.LongPollDelay) === "number") {                                    delay = data.LongPollDelay;                                }                                if (data && data.Disconnect) {                                    return;                                }                                if (isDisconnecting(instance) === true) {                                    return;                                }                                shouldReconnect = data && data.ShouldReconnect;                                if (shouldReconnect) {                                    // Transition into the reconnecting state                                    // If this fails then that means that the user transitioned the connection into a invalid state in processMessages.                                    if (!transportLogic.ensureReconnectingState(instance)) {                                        return;                                    }                                }                                // We never want to pass a raiseReconnect flag after a successful poll.  This is handled via the error function                                if (delay > 0) {                                    privateData.pollTimeoutId = window.setTimeout(function () {                                        poll(instance, shouldReconnect);                                    }, delay);                                } else {                                    poll(instance, shouldReconnect);                                }                            },                            error: function (data, textStatus) {                                // Stop trying to trigger reconnect, connection is in an error state                                // If we're not in the reconnect state this will noop                                window.clearTimeout(privateData.reconnectTimeoutId);                                privateData.reconnectTimeoutId = null;                                if (textStatus === "abort") {                                    connection.log("Aborted xhr request.");                                    return;                                }                                if (!tryFailConnect()) {                                    // Increment our reconnect errors, we assume all errors to be reconnect errors                                    // In the case that it's our first error this will cause Reconnect to be fired                                    // after 1 second due to reconnectErrors being = 1.                                    reconnectErrors++;                                    if (connection.state !== signalR.connectionState.reconnecting) {                                        connection.log("An error occurred using longPolling. Status = " + textStatus + ".  Response = " + data.responseText + ".");                                        $(instance).triggerHandler(events.onError, [signalR._.transportError(signalR.resources.longPollFailed, connection.transport, data, instance.pollXhr)]);                                    }                                    // We check the state here to verify that we're not in an invalid state prior to verifying Reconnect.                                    // If we're not in connected or reconnecting then the next ensureReconnectingState check will fail and will return.                                    // Therefore we don't want to change that failure code path.                                    if ((connection.state === signalR.connectionState.connected ||                                        connection.state === signalR.connectionState.reconnecting) &&                                        !transportLogic.verifyLastActive(connection)) {                                        return;                                    }                                    // Transition into the reconnecting state                                    // If this fails then that means that the user transitioned the connection into the disconnected or connecting state within the above error handler trigger.                                    if (!transportLogic.ensureReconnectingState(instance)) {                                        return;                                    }                                    // Call poll with the raiseReconnect flag as true after the reconnect delay                                    privateData.pollTimeoutId = window.setTimeout(function () {                                        poll(instance, true);                                    }, that.reconnectDelay);                                }                            }                        }                    ));                    // This will only ever pass after an error has occured via the poll ajax procedure.                    if (reconnecting && raiseReconnect === true) {                        // We wait to reconnect depending on how many times we've failed to reconnect.                        // This is essentially a heuristic that will exponentially increase in wait time before                        // triggering reconnected.  This depends on the "error" handler of Poll to cancel this                        // timeout if it triggers before the Reconnected event fires.                        // The Math.min at the end is to ensure that the reconnect timeout does not overflow.                        privateData.reconnectTimeoutId = window.setTimeout(function () { fireReconnected(instance); }, Math.min(1000 * (Math.pow(2, reconnectErrors) - 1), maxFireReconnectedTimeout));                    }                }(connection));            }, 250); // Have to delay initial poll so Chrome doesn't show loader spinner in tab        },        lostConnection: function (connection) {            throw new Error("Lost Connection not handled for LongPolling");        },        send: function (connection, data) {            transportLogic.ajaxSend(connection, data);        },        stop: function (connection) {            /// <summary>Stops the long polling connection</summary>            /// <param name="connection" type="signalR">The SignalR connection to stop</param>            window.clearTimeout(connection._.pollTimeoutId);            window.clearTimeout(connection._.reconnectTimeoutId);            delete connection._.pollTimeoutId;            delete connection._.reconnectTimeoutId;            if (connection.pollXhr) {                connection.pollXhr.abort();                connection.pollXhr = null;                delete connection.pollXhr;            }        },        abort: function (connection, async) {            transportLogic.ajaxAbort(connection, async);        }    };}(window.jQuery, window));/* jquery.signalR.hubs.js */// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.md in the project root for license information./*global window:false *//// <reference path="jquery.signalR.core.js" />(function ($, window, undefined) {    "use strict";    var eventNamespace = ".hubProxy",        signalR = $.signalR;    function makeEventName(event) {        return event + eventNamespace;    }    // Equivalent to Array.prototype.map    function map(arr, fun, thisp) {        var i,            length = arr.length,            result = [];        for (i = 0; i < length; i += 1) {            if (arr.hasOwnProperty(i)) {                result[i] = fun.call(thisp, arr[i], i, arr);            }        }        return result;    }    function getArgValue(a) {        return $.isFunction(a) ? null : ($.type(a) === "undefined" ? null : a);    }    function hasMembers(obj) {        for (var key in obj) {            // If we have any properties in our callback map then we have callbacks and can exit the loop via return            if (obj.hasOwnProperty(key)) {                return true;            }        }        return false;    }    function clearInvocationCallbacks(connection, error) {        /// <param name="connection" type="hubConnection" />        var callbacks = connection._.invocationCallbacks,            callback;        if (hasMembers(callbacks)) {            connection.log("Clearing hub invocation callbacks with error: " + error + ".");        }        // Reset the callback cache now as we have a local var referencing it        connection._.invocationCallbackId = 0;        delete connection._.invocationCallbacks;        connection._.invocationCallbacks = {};        // Loop over the callbacks and invoke them.        // We do this using a local var reference and *after* we've cleared the cache        // so that if a fail callback itself tries to invoke another method we don't        // end up with its callback in the list we're looping over.        for (var callbackId in callbacks) {            callback = callbacks[callbackId];            callback.method.call(callback.scope, { E: error });        }    }    // hubProxy    function hubProxy(hubConnection, hubName) {        /// <summary>        ///     Creates a new proxy object for the given hub connection that can be used to invoke        ///     methods on server hubs and handle client method invocation requests from the server.        /// </summary>        return new hubProxy.fn.init(hubConnection, hubName);    }    hubProxy.fn = hubProxy.prototype = {        init: function (connection, hubName) {            this.state = {};            this.connection = connection;            this.hubName = hubName;            this._ = {                callbackMap: {}            };        },        hasSubscriptions: function () {            return hasMembers(this._.callbackMap);        },        on: function (eventName, callback) {            /// <summary>Wires up a callback to be invoked when a invocation request is received from the server hub.</summary>            /// <param name="eventName" type="String">The name of the hub event to register the callback for.</param>            /// <param name="callback" type="Function">The callback to be invoked.</param>            var that = this,                callbackMap = that._.callbackMap;            // Normalize the event name to lowercase            eventName = eventName.toLowerCase();            // If there is not an event registered for this callback yet we want to create its event space in the callback map.            if (!callbackMap[eventName]) {                callbackMap[eventName] = {};            }            // Map the callback to our encompassed function            callbackMap[eventName][callback] = function (e, data) {                callback.apply(that, data);            };            $(that).bind(makeEventName(eventName), callbackMap[eventName][callback]);            return that;        },        off: function (eventName, callback) {            /// <summary>Removes the callback invocation request from the server hub for the given event name.</summary>            /// <param name="eventName" type="String">The name of the hub event to unregister the callback for.</param>            /// <param name="callback" type="Function">The callback to be invoked.</param>            var that = this,                callbackMap = that._.callbackMap,                callbackSpace;            // Normalize the event name to lowercase            eventName = eventName.toLowerCase();            callbackSpace = callbackMap[eventName];            // Verify that there is an event space to unbind            if (callbackSpace) {                // Only unbind if there's an event bound with eventName and a callback with the specified callback                if (callbackSpace[callback]) {                    $(that).unbind(makeEventName(eventName), callbackSpace[callback]);                    // Remove the callback from the callback map                    delete callbackSpace[callback];                    // Check if there are any members left on the event, if not we need to destroy it.                    if (!hasMembers(callbackSpace)) {                        delete callbackMap[eventName];                    }                } else if (!callback) { // Check if we're removing the whole event and we didn't error because of an invalid callback                    $(that).unbind(makeEventName(eventName));                    delete callbackMap[eventName];                }            }            return that;        },        invoke: function (methodName) {            /// <summary>Invokes a server hub method with the given arguments.</summary>            /// <param name="methodName" type="String">The name of the server hub method.</param>            var that = this,                connection = that.connection,                args = $.makeArray(arguments).slice(1),                argValues = map(args, getArgValue),                data = { H: that.hubName, M: methodName, A: argValues, I: connection._.invocationCallbackId },                d = $.Deferred(),                callback = function (minResult) {                    var result = that._maximizeHubResponse(minResult),                        source,                        error;                    // Update the hub state                    $.extend(that.state, result.State);                    if (result.Error) {                        // Server hub method threw an exception, log it & reject the deferred                        if (result.StackTrace) {                            connection.log(result.Error + "\n" + result.StackTrace + ".");                        }                        // result.ErrorData is only set if a HubException was thrown                        source = result.IsHubException ? "HubException" : "Exception";                        error = signalR._.error(result.Error, source);                        error.data = result.ErrorData;                        connection.log(that.hubName + "." + methodName + " failed to execute. Error: " + error.message);                        d.rejectWith(that, [error]);                    } else {                        // Server invocation succeeded, resolve the deferred                        connection.log("Invoked " + that.hubName + "." + methodName);                        d.resolveWith(that, [result.Result]);                    }                };            connection._.invocationCallbacks[connection._.invocationCallbackId.toString()] = { scope: that, method: callback };            connection._.invocationCallbackId += 1;            if (!$.isEmptyObject(that.state)) {                data.S = that.state;            }            connection.log("Invoking " + that.hubName + "." + methodName);            connection.send(data);            return d.promise();        },        _maximizeHubResponse: function (minHubResponse) {            return {                State: minHubResponse.S,                Result: minHubResponse.R,                Id: minHubResponse.I,                IsHubException: minHubResponse.H,                Error: minHubResponse.E,                StackTrace: minHubResponse.T,                ErrorData: minHubResponse.D            };        }    };    hubProxy.fn.init.prototype = hubProxy.fn;    // hubConnection    function hubConnection(url, options) {        /// <summary>Creates a new hub connection.</summary>        /// <param name="url" type="String">[Optional] The hub route url, defaults to "/signalr".</param>        /// <param name="options" type="Object">[Optional] Settings to use when creating the hubConnection.</param>        var settings = {            qs: null,            logging: false,            useDefaultPath: true        };        $.extend(settings, options);        if (!url || settings.useDefaultPath) {            url = (url || "") + "/signalr";        }        return new hubConnection.fn.init(url, settings);    }    hubConnection.fn = hubConnection.prototype = $.connection();    hubConnection.fn.init = function (url, options) {        var settings = {                qs: null,                logging: false,                useDefaultPath: true            },            connection = this;        $.extend(settings, options);        // Call the base constructor        $.signalR.fn.init.call(connection, url, settings.qs, settings.logging);        // Object to store hub proxies for this connection        connection.proxies = {};        connection._.invocationCallbackId = 0;        connection._.invocationCallbacks = {};        // Wire up the received handler        connection.received(function (minData) {            var data, proxy, dataCallbackId, callback, hubName, eventName;            if (!minData) {                return;            }            if (typeof (minData.I) !== "undefined") {                // We received the return value from a server method invocation, look up callback by id and call it                dataCallbackId = minData.I.toString();                callback = connection._.invocationCallbacks[dataCallbackId];                if (callback) {                    // Delete the callback from the proxy                    connection._.invocationCallbacks[dataCallbackId] = null;                    delete connection._.invocationCallbacks[dataCallbackId];                    // Invoke the callback                    callback.method.call(callback.scope, minData);                }            } else {                data = this._maximizeClientHubInvocation(minData);                // We received a client invocation request, i.e. broadcast from server hub                connection.log("Triggering client hub event '" + data.Method + "' on hub '" + data.Hub + "'.");                // Normalize the names to lowercase                hubName = data.Hub.toLowerCase();                eventName = data.Method.toLowerCase();                // Trigger the local invocation event                proxy = this.proxies[hubName];                // Update the hub state                $.extend(proxy.state, data.State);                $(proxy).triggerHandler(makeEventName(eventName), [data.Args]);            }        });        connection.error(function (errData, origData) {            var callbackId, callback;            if (!origData) {                // No original data passed so this is not a send error                return;            }            callbackId = origData.I;            callback = connection._.invocationCallbacks[callbackId];            // Verify that there is a callback bound (could have been cleared)            if (callback) {                // Delete the callback                connection._.invocationCallbacks[callbackId] = null;                delete connection._.invocationCallbacks[callbackId];                // Invoke the callback with an error to reject the promise                callback.method.call(callback.scope, { E: errData });            }        });        connection.reconnecting(function () {            if (connection.transport && connection.transport.name === "webSockets") {                clearInvocationCallbacks(connection, "Connection started reconnecting before invocation result was received.");            }        });        connection.disconnected(function () {            clearInvocationCallbacks(connection, "Connection was disconnected before invocation result was received.");        });    };    hubConnection.fn._maximizeClientHubInvocation = function (minClientHubInvocation) {        return {            Hub: minClientHubInvocation.H,            Method: minClientHubInvocation.M,            Args: minClientHubInvocation.A,            State: minClientHubInvocation.S        };    };    hubConnection.fn._registerSubscribedHubs = function () {        /// <summary>        ///     Sets the starting event to loop through the known hubs and register any new hubs        ///     that have been added to the proxy.        /// </summary>        var connection = this;        if (!connection._subscribedToHubs) {            connection._subscribedToHubs = true;            connection.starting(function () {                // Set the connection's data object with all the hub proxies with active subscriptions.                // These proxies will receive notifications from the server.                var subscribedHubs = [];                $.each(connection.proxies, function (key) {                    if (this.hasSubscriptions()) {                        subscribedHubs.push({ name: key });                        connection.log("Client subscribed to hub '" + key + "'.");                    }                });                if (subscribedHubs.length === 0) {                    connection.log("No hubs have been subscribed to.  The client will not receive data from hubs.  To fix, declare at least one client side function prior to connection start for each hub you wish to subscribe to.");                }                connection.data = connection.json.stringify(subscribedHubs);            });        }    };    hubConnection.fn.createHubProxy = function (hubName) {        /// <summary>        ///     Creates a new proxy object for the given hub connection that can be used to invoke        ///     methods on server hubs and handle client method invocation requests from the server.        /// </summary>        /// <param name="hubName" type="String">        ///     The name of the hub on the server to create the proxy for.        /// </param>        // Normalize the name to lowercase        hubName = hubName.toLowerCase();        var proxy = this.proxies[hubName];        if (!proxy) {            proxy = hubProxy(this, hubName);            this.proxies[hubName] = proxy;        }        this._registerSubscribedHubs();        return proxy;    };    hubConnection.fn.init.prototype = hubConnection.fn;    $.hubConnection = hubConnection;}(window.jQuery, window));/* jquery.signalR.version.js */// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.md in the project root for license information./*global window:false *//// <reference path="jquery.signalR.core.js" />(function ($, undefined) {    $.signalR.version = "2.0.3";}(window.jQuery));
compiled/src/vendor.js:44269:            // TODO: We need to take the current isoWeekYear, but that depends on
compiled/src/vendor.js:45390:        // TODO: Move this out of here!
compiled/src/vendor.js:45393:            // TODO: Another silent failure?
compiled/src/vendor.js:46514:    // TODO: Maybe we should throw on null here? It's not really good style to use '' and null interchangeabley
compiled/src/vendor.js:46804:      // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree
compiled/src/vendor.js:47659:      // TODO: We may not want to bump 'transition' if we're called from a location change that we've initiated ourselves,
compiled/src/vendor.js:56122:  // TODO: add support for Arrays to deepExtend
compiled/src/vendor.js:57017:// TODO: add a DataSet constructor DataSet(data, options)
compiled/src/vendor.js:57046:  // TODO: deprecated since version 1.1.1 (or 2.0.0?)
compiled/src/vendor.js:57080:// TODO: make this function deprecated (replaced with `on` since version 0.5)
compiled/src/vendor.js:57097:// TODO: make this function deprecated (replaced with `on` since version 0.5)
compiled/src/vendor.js:57608:  // TODO: extend order by an Object {field:String, direction:String}
compiled/src/vendor.js:57932:// TODO: implement a function .config() to dynamically update things like configured filter
compiled/src/vendor.js:58187:// TODO: make these functions deprecated (replaced with `on` and `off` since version 0.5)
compiled/src/vendor.js:58249:        // TODO: optimize checking for overlap. when there is a gap without items,
compiled/src/vendor.js:59282:  // TODO: reckon with min and max range
compiled/src/vendor.js:59390:    // TODO: implement timeaxis orientations 'left' and 'right'
compiled/src/vendor.js:59464:  // TODO: recalculate sizes only needed when parent is resized or options is changed
compiled/src/vendor.js:59477:  props.minorLineWidth = 1; // TODO: really calculate width
compiled/src/vendor.js:59479:  props.majorLineWidth = 1; // TODO: really calculate width
compiled/src/vendor.js:59545:    // TODO: lines must have a width, such that we can create css backgrounds
compiled/src/vendor.js:59614:  //label.title = title;  // TODO: this is a heavy operation
compiled/src/vendor.js:59639:  //label.title = title; // TODO: this is a heavy operation
compiled/src/vendor.js:60483:  // TODO: would be nicer to get this as a trigger from Range
compiled/src/vendor.js:60757:        item.id = id; // TODO: not so nice setting id afterwards
compiled/src/vendor.js:60808:  // TODO: optimization: only reorder groups affected by the changed items
compiled/src/vendor.js:61129:    // TODO: implement onMoving handler
compiled/src/vendor.js:61285:        // TODO: need to trigger a redraw?
compiled/src/vendor.js:61398: *                                  // TODO: describe available options
compiled/src/vendor.js:61539: *                                  // TODO: describe available options
compiled/src/vendor.js:61572:  // TODO: account for the real width of the item. Right now we just add 1/4 to the window
compiled/src/vendor.js:61751:    var itemSetHeight = this.parent.itemSet.props.height; // TODO: this is nasty
compiled/src/vendor.js:61770: *                                  // TODO: describe available options
compiled/src/vendor.js:61804:  // TODO: account for the real width of the item. Right now we just add 1/4 to the window
compiled/src/vendor.js:61887:    //dom.content.style.marginRight = ... + 'px'; // TODO: margin right
compiled/src/vendor.js:61961: *                                  // TODO: describe options
compiled/src/vendor.js:62126:    // TODO: remove the need for options.padding. it's terrible.
compiled/src/vendor.js:62167:    // TODO: this should be redundant?
compiled/src/vendor.js:62197:    // TODO: this should be redundant?
compiled/src/vendor.js:62224: *                                  // TODO: describe options
compiled/src/vendor.js:62416:  if (this.itemSet.options.stack) { // TODO: ugly way to access options...
compiled/src/vendor.js:62519:    var range = this.itemSet.body.range; // TODO: not nice accessing the range like this
compiled/src/vendor.js:62536:  // TODO: also remove from ordered items?
compiled/src/vendor.js:63028:  // TODO: remove deprecation error one day (deprecated since version 0.8.0)
compiled/src/vendor.js:63312:  // TODO: compensate borders when any of the panels is empty.
compiled/src/vendor.js:63315:  // TODO: only calculate autoHeight when needed (else we cause an extra reflow/repaint of the DOM)
compiled/src/vendor.js:63412:// TODO: deprecated since version 1.1.0, remove some day
compiled/src/vendor.js:63423:// TODO: move this function to Range
compiled/src/vendor.js:63436:// TODO: move this function to Range
compiled/src/vendor.js:63548:    this.redraw(); // TODO: this causes two redraws when dragging, the other is triggered by rangechange already
compiled/src/vendor.js:63916:    // TODO: more precise parsing of numbers/strings (and the port separator ':')
compiled/src/vendor.js:64072:      // TODO: implement comma separated list with "a_list: ID=ID [','] [a_list] "
compiled/src/vendor.js:64602:    // TODO: allow to customize different shapes
compiled/src/vendor.js:64650:  // TODO: add diamond shape
compiled/src/vendor.js:64863:    // TODO: add diamond shape
compiled/src/vendor.js:64944:    // TODO: implement distanceToBorder for database
compiled/src/vendor.js:64945:    // TODO: implement distanceToBorder for triangle
compiled/src/vendor.js:64946:    // TODO: implement distanceToBorder for triangleDown
compiled/src/vendor.js:64956:        // TODO: reckon with border radius too in case of box
compiled/src/vendor.js:64963:  // TODO: implement calculation of distance to border for all shapes
compiled/src/vendor.js:65051:// TODO: replace this method with calculating the kinetic energy
compiled/src/vendor.js:65135:  // TODO: pre calculate the image size
compiled/src/vendor.js:65987:    // TODO: cache the calculated size
compiled/src/vendor.js:66314:    // TODO: similarly, for a line without arrows, draw to the border of the nodes instead of the center
compiled/src/vendor.js:72356:    // TODO: work out these options and document them
compiled/src/vendor.js:72775:  // TODO: enabled moving while pinching?
compiled/src/vendor.js:74021:  this.showGrayBottom = false; // TODO: this does not work correctly
compiled/src/vendor.js:74029:  this.eye = new Point3d(0, 0, -1);  // TODO: set eye.z about 3/4 of the width of the window?
compiled/src/vendor.js:74054:  // TODO: customize axis range
compiled/src/vendor.js:74231:  // TODO: can this be automated? verticalRatio?
compiled/src/vendor.js:74603:  // TODO: store the created matrix dataPoints in the filters instead of reloading each time
compiled/src/vendor.js:74641:      var xIndex = dataX.indexOf(x);  // TODO: implement Array().indexOf() for Internet Explorer
compiled/src/vendor.js:74759:  // TODO: these events are never cleaned up... can give a 'memory leakage'
compiled/src/vendor.js:75088:  ctx.font = '14px arial'; // TODO: put in options
compiled/src/vendor.js:75171:    // TODO: css here is not nice here...
compiled/src/vendor.js:75213:    ctx.font = '14px arial'; // TODO: put in options
compiled/src/vendor.js:75237:  // TODO: get the actual rendered style of the containerElement
compiled/src/vendor.js:75374:    // TODO: make z-grid lines really 3d?
compiled/src/vendor.js:75485:    offset = 30;  // pixels.  // TODO: relate to the max width of the values on the z axis?
compiled/src/vendor.js:75539:    return; // TODO: throw exception?
compiled/src/vendor.js:75593:            v = Math.min(1 + (crossproduct.x / len) / 2, 1);  // value. TODO: scale
compiled/src/vendor.js:75678:    return;  // TODO: throw exception?
compiled/src/vendor.js:75774:    return;  // TODO: throw exception?
compiled/src/vendor.js:75864:      // TODO: this dept calculation doesn't work 100% of the cases due to perspective,
compiled/src/vendor.js:75913:    return;  // TODO: throw exception?
compiled/src/vendor.js:75928:    ctx.lineWidth = 1;    // TODO: make customizable
compiled/src/vendor.js:75929:    ctx.strokeStyle = 'blue'; // TODO: make customizable
compiled/src/vendor.js:76720:    //this.graph.redrawInfo(); // TODO: not neat
compiled/src/vendor.js:76731:    // TODO: this is no nice solution...
compiled/src/vendor.js:76732:    frame.progress.style.bottom = Graph3d.px(60); // TODO: use height of slider
compiled/src/vendor.js:77016:  // document.title = diff // TODO: cleanup
compiled/src/vendor.js:80174:            // TODO: We need to take the current isoWeekYear, but that depends on
compiled/src/vendor.js:81295:        // TODO: Move this out of here!
compiled/src/vendor.js:81298:            // TODO: Another silent failure?
compiled/src/vendor.js:82321:       * TODO: actually remove this from the _callbacks dictionary instead
compiled/src/vendor.js:82662:		// TODO: determine which cases actually cause this to happen
compiled/src/vendor.js:82791:				// TODO: add this back in 1.9 and use $.error() (see #5972)
compiled/src/vendor.js:82994:	// TODO: make sure destroying one instance of mouse doesn't mess with
compiled/src/vendor.js:84339:				//TODO : this modifies original option
compiled/src/vendor.js:84342:				//TODO : What's going on here?
compiled/src/vendor.js:84383:				//TODO: What's that good for? There's not anything to be executed left
compiled/src/vendor.js:84390:		//TODO: make renderAxis a prototype function
compiled/src/vendor.js:84439:		//TODO: Unwrap at same DOM position
compiled/src/vendor.js:84562:				soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : self.sizeDiff.height,
compiled/src/vendor.js:84711:			// fix ie6 offset TODO: This seems broken
compiled/src/vendor.js:84721:				zIndex: ++o.zIndex //TODO: Don't modify option
compiled/src/vendor.js:84882:					soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : self.sizeDiff.height,
compiled/src/vendor.js:85496:		// TODO: Still need to figure out a way to make relative sorting possible
compiled/src/vendor.js:86027:		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
compiled/src/vendor.js:86899:			// TODO: make effects take actual parameters instead of a hash
compiled/src/vendor.js:88297:		// TODO this gets called on init, changing the option without an explicit call for that
compiled/src/vendor.js:88316:	// TODO isn't event.target enough? why the separate target argument?
compiled/src/vendor.js:88352:		// TODO the option is changed, is that correct?
compiled/src/vendor.js:88353:		// TODO if it is correct, shouldn't that happen after determining that the click is valid?
compiled/src/vendor.js:88489:		// TODO assert that the blur and focus triggers are really necessary, remove otherwise
compiled/src/vendor.js:88665:			// TODO verify these actually work as intended
compiled/src/vendor.js:88980:		// TODO refresh should check if the active item is still in the dom, removing the need for a manual deactivate
compiled/src/vendor.js:89169:	// TODO merge with previousPage
compiled/src/vendor.js:89172:			// TODO merge with no-scroll-else
compiled/src/vendor.js:89181:					// TODO improve approximation
compiled/src/vendor.js:89185:			// TODO try to catch this earlier when scrollTop indicates the last page anyway
compiled/src/vendor.js:89196:	// TODO merge with nextPage
compiled/src/vendor.js:89199:			// TODO merge with no-scroll-else
compiled/src/vendor.js:89209:					// TODO improve approximation
compiled/src/vendor.js:89213:			// TODO try to catch this earlier when scrollTop indicates the last page anyway
compiled/src/vendor.js:89433:						// TODO pass through original event correctly (just as 2nd argument doesn't work)
compiled/src/vendor.js:89440:		// TODO: pull out $.Widget's handling for the disabled option into
compiled/src/vendor.js:89777:	// TODO rename to "widget" when switching to widget factory
compiled/src/vendor.js:91659:		//TODO: remove in 1.9pre
compiled/src/vendor.js:92060:			//TODO: remove in 1.9pre
compiled/src/vendor.js:92390:	// TODO: use $.isWindow() in 1.9
compiled/src/vendor.js:93513:				// TODO until #3808 is fixed strip fragment identifier from url
compiled/src/vendor.js:93563:			} else if ( o.selected === null ) { // usage of null is deprecated, TODO remove in next release
compiled/src/vendor.js:93603:			// TODO: namespace this event
compiled/src/vendor.js:93614:		// TODO: use .toggleClass()
compiled/src/vendor.js:93625:				// TODO: use .toggleClass()
compiled/src/vendor.js:93760:					// TODO make passing in node possible, see also http://dev.jqueryui.com/ticket/3171
compiled/src/vendor.js:94405:TODO: this file should be refactored to work more clear without closures!
compiled/src/vendor.js:96225:	t.getDefaultEventEnd = function(allDay, start) { // TODO: rename to computeDefaultEventEnd
compiled/src/vendor.js:96251:		// a function that returns a formatStr // TODO: in future, precompute this
compiled/src/vendor.js:96263:		// a function that returns a formatStr // TODO: in future, precompute this
compiled/src/vendor.js:96563:	// TODO: going forward, most of this stuff should be directly handled by the view
compiled/src/vendor.js:96578:	function renderEvents(modifiedEventID) { // TODO: remove modifiedEventID hack
compiled/src/vendor.js:96589:		currentView.clearEventData(); // for View.js, TODO: unify with clearEvents
compiled/src/vendor.js:96775:		// TODO: unbind on destroy
compiled/src/vendor.js:97233:				// TODO: repeat code, same code for event classNames
compiled/src/vendor.js:97838://TODO: arraySlice
compiled/src/vendor.js:97839://TODO: isFunction, grep ?
compiled/src/vendor.js:97905:function markFirstLast(e) { // TODO: use CSS selectors instead
compiled/src/vendor.js:98156:	this.year(a[0]) // TODO: find a way to do this in one shot
compiled/src/vendor.js:98190:	this.year(a[0]) // TODO: find a way to do this in one shot
compiled/src/vendor.js:98242:		this.year(a[0]) // TODO: find a way to do this in one shot
compiled/src/vendor.js:98411:// TODO: make it work with timezone offset
compiled/src/vendor.js:98505:// TODO: week maybe?
compiled/src/vendor.js:98549:	var chunker = /\[([^\]]*)\]|\(([^\)]*)\)|(LT|(\w)\4*o?)|([^\w\[\(]+)/g; // TODO: more descrimination
compiled/src/vendor.js:98627:function BasicWeekView(element, calendar) { // TODO: do a WeekView mixin
compiled/src/vendor.js:98670:function BasicDayView(element, calendar) { // TODO: make a DayView mixin
compiled/src/vendor.js:99060:	// TODO: should be consolidated with AgendaView's methods
compiled/src/vendor.js:99244:	// TODO: have this class (and AgendaEventRenderer) be responsible for creating the event container div
compiled/src/vendor.js:99252:function AgendaWeekView(element, calendar) { // TODO: do a WeekView mixin
compiled/src/vendor.js:99295:function AgendaDayView(element, calendar) { // TODO: make a DayView mixin
compiled/src/vendor.js:99366:// TODO: make it work in quirks mode (event corners, all-day height)
compiled/src/vendor.js:99367:// TODO: test liquid width, especially in IE6
compiled/src/vendor.js:99457:	var slotHeight; // TODO: what if slotHeight changes? (see issue 650)
compiled/src/vendor.js:99645:		// TODO: now that we rebuild the cells every time, we should call dayRender
compiled/src/vendor.js:99707:		var headerClass = tm + "-widget-header"; // TODO: make these when updateOptions() called
compiled/src/vendor.js:99768:	// TODO: data-date on the cells
compiled/src/vendor.js:99901:			var match = this.parentNode.className.match(/fc-slot(\d+)/); // TODO: maybe use data
compiled/src/vendor.js:99927:	// TODO: should be consolidated with BasicView's methods
compiled/src/vendor.js:100058:	function getIsCellAllDay(cell) { // TODO: remove because mom.hasTime() from realCellToDate() is better
compiled/src/vendor.js:100459:	// TODO: when we refactor this, when user returns `false` eventRender, don't have empty space
compiled/src/vendor.js:100460:	// TODO: refactor will include using pixels to detect collisions instead of dates (handy for seg cmp)
compiled/src/vendor.js:100494:			// TODO: move this to CSS somehow
compiled/src/vendor.js:100587:					// not enough room for title, put it in the time (TODO: maybe make both display:inline instead)
compiled/src/vendor.js:101264:	var eventElementCouples = []; // array of objects, { event, element } // TODO: unify with segment system
compiled/src/vendor.js:101373:		// TODO: don't fire eventMouseover/eventMouseout *while* dragging is occuring (on subject element)
compiled/src/vendor.js:101374:		// TODO: same for resizing
compiled/src/vendor.js:101769:	var allDayRow = t.allDayRow; // TODO: rename
compiled/src/vendor.js:102034:		// TODO:
compiled/src/vendor.js:102271:	// TODO: better documentation!
compiled/src/vendor.js:102364:		var handle = element.find('.ui-resizable-' + direction); // TODO: stop using this class because we aren't using jqui for this
compiled/src/vendor.js:102367:		// TODO: look into using jquery-ui mouse widget for this stuff
compiled/src/vendor.js:102436:						// TODO: instead of calling renderDayOverlay() with dates,
compiled/src/vendor.js:102490:function segmentElementEach(segments, callback) { // TODO: use in AgendaView?
compiled/src/vendor.js:102571:	// TODO: better date normalization. see notes in automated test
compiled/src/vendor.js:102598:			hoverListener.start(function(cell, origCell) { // TODO: maybe put cellToDate/getIsCellAllDay info in cell
css/timeline-theme.css:61:  /* TODO: find a nice way to ensure shadows are drawn on top of items
css/timeline-theme.css:335:/* TODO: get animation working nicely
libs/angular.js:662:  // TODO: we should move this into IE/ES5 polyfill
libs/angular.js:1476://TODO(misko): this function needs to be removed
libs/angular.js:3960:    // TODO(vojta): use filter if we change it to accept lists as well
libs/angular.js:4290:  // TODO(vojta): remove this temporary api
libs/angular.js:4318:   * TODO(vojta): prefix this method with $$ ?
libs/angular.js:4468:    // TODO(vojta): refactor to use node's syntax for events
libs/angular.js:5750:        // TODO: decide whether or not to throw an error if "class"
libs/angular.js:6891:                // TODO(i): this should likely be attr.$set(name, iterpolateFn(scope) so that we reset the
libs/angular.js:8296:  // TODO(vojta): fix the signature
libs/angular.js:9539:      // TODO(vojta): rewrite link when opening in new tab/window (in legacy browser)
libs/angular.js:10196:    //TODO(i): strip all the obsolte json stuff from this file
libs/angular.js:10338:        // TODO(size): maybe we should not support multiple statements?
libs/angular.js:17847:    // TODO: move this to scenario runner
libs/angular.js:21212:        // TODO(vojta): can't we optimize this ?
libs/angular_cookies.js:75:      //TODO: this should happen before the "delayed" watches fire, because if some cookies are not
libs/angular_loadingbar.js:237:        // TODO: do this mathmatically instead of through conditions
libs/angular_mocks.js:46:  // TODO(vojta): remove this temporary api
libs/angular_mocks.js:851:        // TODO(i): this prevents methods being logged,
libs/angular_mocks.js:1110:  // TODO(vojta): change params to: method, url, data, headers, callback
libs/angular_strap.js:216:// @TODO: submit issue to core
libs/jquery_signalr.js:1:/* jquery.signalR.core.js *//*global window:false *//*! * ASP.NET SignalR JavaScript Library v2.0.3 * http://signalr.net/ * * Copyright (C) Microsoft Corporation. All rights reserved. * *//// <reference path="Scripts/jquery-1.6.4.js" />/// <reference path="jquery.signalR.version.js" />(function ($, window, undefined) {    "use strict";    var resources = {        nojQuery: "jQuery was not found. Please ensure jQuery is referenced before the SignalR client JavaScript file.",        noTransportOnInit: "No transport could be initialized successfully. Try specifying a different transport or none at all for auto initialization.",        errorOnNegotiate: "Error during negotiation request.",        stoppedWhileLoading: "The connection was stopped during page load.",        stoppedWhileNegotiating: "The connection was stopped during the negotiate request.",        errorParsingNegotiateResponse: "Error parsing negotiate response.",        protocolIncompatible: "You are using a version of the client that isn't compatible with the server. Client version {0}, server version {1}.",        sendFailed: "Send failed.",        parseFailed: "Failed at parsing response: {0}",        longPollFailed: "Long polling request failed.",        eventSourceFailedToConnect: "EventSource failed to connect.",        eventSourceError: "Error raised by EventSource",        webSocketClosed: "WebSocket closed.",        pingServerFailedInvalidResponse: "Invalid ping response when pinging server: '{0}'.",        pingServerFailed: "Failed to ping server.",        pingServerFailedStatusCode: "Failed to ping server.  Server responded with status code {0}, stopping the connection.",        pingServerFailedParse: "Failed to parse ping server response, stopping the connection.",        noConnectionTransport: "Connection is in an invalid state, there is no transport active.",        webSocketsInvalidState: "The Web Socket transport is in an invalid state, transitioning into reconnecting."    };    if (typeof ($) !== "function") {        // no jQuery!        throw new Error(resources.nojQuery);    }    var signalR,        _connection,        _pageLoaded = (window.document.readyState === "complete"),        _pageWindow = $(window),        _negotiateAbortText = "__Negotiate Aborted__",        events = {            onStart: "onStart",            onStarting: "onStarting",            onReceived: "onReceived",            onError: "onError",            onConnectionSlow: "onConnectionSlow",            onReconnecting: "onReconnecting",            onReconnect: "onReconnect",            onStateChanged: "onStateChanged",            onDisconnect: "onDisconnect"        },        ajaxDefaults = {            processData: true,            timeout: null,            async: true,            global: false,            cache: false        },        log = function (msg, logging) {            if (logging === false) {                return;            }            var m;            if (typeof (window.console) === "undefined") {                return;            }            m = "[" + new Date().toTimeString() + "] SignalR: " + msg;            if (window.console.debug) {                window.console.debug(m);            } else if (window.console.log) {                window.console.log(m);            }        },        changeState = function (connection, expectedState, newState) {            if (expectedState === connection.state) {                connection.state = newState;                $(connection).triggerHandler(events.onStateChanged, [{ oldState: expectedState, newState: newState }]);                return true;            }            return false;        },        isDisconnecting = function (connection) {            return connection.state === signalR.connectionState.disconnected;        },        configureStopReconnectingTimeout = function (connection) {            var stopReconnectingTimeout,                onReconnectTimeout;            // Check if this connection has already been configured to stop reconnecting after a specified timeout.            // Without this check if a connection is stopped then started events will be bound multiple times.            if (!connection._.configuredStopReconnectingTimeout) {                onReconnectTimeout = function (connection) {                    connection.log("Couldn't reconnect within the configured timeout (" + connection.disconnectTimeout + "ms), disconnecting.");                    connection.stop(/* async */ false, /* notifyServer */ false);                };                connection.reconnecting(function () {                    var connection = this;                    // Guard against state changing in a previous user defined even handler                    if (connection.state === signalR.connectionState.reconnecting) {                        stopReconnectingTimeout = window.setTimeout(function () { onReconnectTimeout(connection); }, connection.disconnectTimeout);                    }                });                connection.stateChanged(function (data) {                    if (data.oldState === signalR.connectionState.reconnecting) {                        // Clear the pending reconnect timeout check                        window.clearTimeout(stopReconnectingTimeout);                    }                });                connection._.configuredStopReconnectingTimeout = true;            }        };    signalR = function (url, qs, logging) {        /// <summary>Creates a new SignalR connection for the given url</summary>        /// <param name="url" type="String">The URL of the long polling endpoint</param>        /// <param name="qs" type="Object">        ///     [Optional] Custom querystring parameters to add to the connection URL.        ///     If an object, every non-function member will be added to the querystring.        ///     If a string, it's added to the QS as specified.        /// </param>        /// <param name="logging" type="Boolean">        ///     [Optional] A flag indicating whether connection logging is enabled to the browser        ///     console/log. Defaults to false.        /// </param>        return new signalR.fn.init(url, qs, logging);    };    signalR._ = {        defaultContentType: "application/x-www-form-urlencoded; charset=UTF-8",        ieVersion: (function () {            var version,                matches;            if (window.navigator.appName === 'Microsoft Internet Explorer') {                // Check if the user agent has the pattern "MSIE (one or more numbers).(one or more numbers)";                matches = /MSIE ([0-9]+\.[0-9]+)/.exec(window.navigator.userAgent);                if (matches) {                    version = window.parseFloat(matches[1]);                }            }            // undefined value means not IE            return version;        })(),        error: function (message, source, context) {            var e = new Error(message);            e.source = source;            if (typeof context !== "undefined") {                e.context = context;            }            return e;        },        transportError: function (message, transport, source, context) {            var e = this.error(message, source, context);            e.transport = transport ? transport.name : undefined;            return e;        },        format: function () {            /// <summary>Usage: format("Hi {0}, you are {1}!", "Foo", 100) </summary>            var s = arguments[0];            for (var i = 0; i < arguments.length - 1; i++) {                s = s.replace("{" + i + "}", arguments[i + 1]);            }            return s;        },        firefoxMajorVersion: function (userAgent) {            // Firefox user agents: http://useragentstring.com/pages/Firefox/            var matches = userAgent.match(/Firefox\/(\d+)/);            if (!matches || !matches.length || matches.length < 2) {                return 0;            }            return parseInt(matches[1], 10 /* radix */);        },        configurePingInterval: function (connection) {            var config = connection._.config,                onFail = function (error) {                    $(connection).triggerHandler(events.onError, [error]);                };            if (config && !connection._.pingIntervalId && config.pingInterval) {                connection._.pingIntervalId = window.setInterval(function () {                    signalR.transports._logic.pingServer(connection).fail(onFail);                }, config.pingInterval);            }        }    };    signalR.events = events;    signalR.resources = resources;    signalR.ajaxDefaults = ajaxDefaults;    signalR.changeState = changeState;    signalR.isDisconnecting = isDisconnecting;    signalR.connectionState = {        connecting: 0,        connected: 1,        reconnecting: 2,        disconnected: 4    };    signalR.hub = {        start: function () {            // This will get replaced with the real hub connection start method when hubs is referenced correctly            throw new Error("SignalR: Error loading hubs. Ensure your hubs reference is correct, e.g. <script src='/signalr/js'></script>.");        }    };    _pageWindow.load(function () { _pageLoaded = true; });    function validateTransport(requestedTransport, connection) {        /// <summary>Validates the requested transport by cross checking it with the pre-defined signalR.transports</summary>        /// <param name="requestedTransport" type="Object">The designated transports that the user has specified.</param>        /// <param name="connection" type="signalR">The connection that will be using the requested transports.  Used for logging purposes.</param>        /// <returns type="Object" />        if ($.isArray(requestedTransport)) {            // Go through transport array and remove an "invalid" tranports            for (var i = requestedTransport.length - 1; i >= 0; i--) {                var transport = requestedTransport[i];                if ($.type(transport) !== "string" || !signalR.transports[transport]) {                    connection.log("Invalid transport: " + transport + ", removing it from the transports list.");                    requestedTransport.splice(i, 1);                }            }            // Verify we still have transports left, if we dont then we have invalid transports            if (requestedTransport.length === 0) {                connection.log("No transports remain within the specified transport array.");                requestedTransport = null;            }        } else if (!signalR.transports[requestedTransport] && requestedTransport !== "auto") {            connection.log("Invalid transport: " + requestedTransport.toString() + ".");            requestedTransport = null;        } else if (requestedTransport === "auto" && signalR._.ieVersion <= 8) {            // If we're doing an auto transport and we're IE8 then force longPolling, #1764            return ["longPolling"];        }        return requestedTransport;    }    function getDefaultPort(protocol) {        if (protocol === "http:") {            return 80;        } else if (protocol === "https:") {            return 443;        }    }    function addDefaultPort(protocol, url) {        // Remove ports  from url.  We have to check if there's a / or end of line        // following the port in order to avoid removing ports such as 8080.        if (url.match(/:\d+$/)) {            return url;        } else {            return url + ":" + getDefaultPort(protocol);        }    }    function ConnectingMessageBuffer(connection, drainCallback) {        var that = this,            buffer = [];        that.tryBuffer = function (message) {            if (connection.state === $.signalR.connectionState.connecting) {                buffer.push(message);                return true;            }            return false;        };        that.drain = function () {            // Ensure that the connection is connected when we drain (do not want to drain while a connection is not active)            if (connection.state === $.signalR.connectionState.connected) {                while (buffer.length > 0) {                    drainCallback(buffer.shift());                }            }        };        that.clear = function () {            buffer = [];        };    }    signalR.fn = signalR.prototype = {        init: function (url, qs, logging) {            var $connection = $(this);            this.url = url;            this.qs = qs;            this._ = {                keepAliveData: {},                connectingMessageBuffer: new ConnectingMessageBuffer(this, function (message) {                    $connection.triggerHandler(events.onReceived, [message]);                }),                onFailedTimeoutHandle: null,                lastMessageAt: new Date().getTime(),                lastActiveAt: new Date().getTime(),                beatInterval: 5000, // Default value, will only be overridden if keep alive is enabled,                beatHandle: null,                totalTransportConnectTimeout: 0 // This will be the sum of the TransportConnectTimeout sent in response to negotiate and connection.transportConnectTimeout            };            if (typeof (logging) === "boolean") {                this.logging = logging;            }        },        _parseResponse: function (response) {            var that = this;            if (!response) {                return response;            } else if (typeof response === "string") {                return that.json.parse(response);            } else {                return response;            }        },        json: window.JSON,        isCrossDomain: function (url, against) {            /// <summary>Checks if url is cross domain</summary>            /// <param name="url" type="String">The base URL</param>            /// <param name="against" type="Object">            ///     An optional argument to compare the URL against, if not specified it will be set to window.location.            ///     If specified it must contain a protocol and a host property.            /// </param>            var link;            url = $.trim(url);            against = against || window.location;            if (url.indexOf("http") !== 0) {                return false;            }            // Create an anchor tag.            link = window.document.createElement("a");            link.href = url;            // When checking for cross domain we have to special case port 80 because the window.location will remove the            return link.protocol + addDefaultPort(link.protocol, link.host) !== against.protocol + addDefaultPort(against.protocol, against.host);        },        ajaxDataType: "text",        contentType: "application/json; charset=UTF-8",        logging: false,        state: signalR.connectionState.disconnected,        clientProtocol: "1.3",        reconnectDelay: 2000,        transportConnectTimeout: 0,        disconnectTimeout: 30000, // This should be set by the server in response to the negotiate request (30s default)        reconnectWindow: 30000, // This should be set by the server in response to the negotiate request        keepAliveWarnAt: 2 / 3, // Warn user of slow connection if we breach the X% mark of the keep alive timeout        start: function (options, callback) {            /// <summary>Starts the connection</summary>            /// <param name="options" type="Object">Options map</param>            /// <param name="callback" type="Function">A callback function to execute when the connection has started</param>            var connection = this,                config = {                    pingInterval: 300000,                    waitForPageLoad: true,                    transport: "auto",                    jsonp: false                },                initialize,                deferred = connection._deferral || $.Deferred(), // Check to see if there is a pre-existing deferral that's being built on, if so we want to keep using it                parser = window.document.createElement("a");            // Persist the deferral so that if start is called multiple times the same deferral is used.            connection._deferral = deferred;            if (!connection.json) {                // no JSON!                throw new Error("SignalR: No JSON parser found. Please ensure json2.js is referenced before the SignalR.js file if you need to support clients without native JSON parsing support, e.g. IE<8.");            }            if ($.type(options) === "function") {                // Support calling with single callback parameter                callback = options;            } else if ($.type(options) === "object") {                $.extend(config, options);                if ($.type(config.callback) === "function") {                    callback = config.callback;                }            }            config.transport = validateTransport(config.transport, connection);            // If the transport is invalid throw an error and abort start            if (!config.transport) {                throw new Error("SignalR: Invalid transport(s) specified, aborting start.");            }            connection._.config = config;            // Check to see if start is being called prior to page load            // If waitForPageLoad is true we then want to re-direct function call to the window load event            if (!_pageLoaded && config.waitForPageLoad === true) {                connection._.deferredStartHandler = function () {                    connection.start(options, callback);                };                _pageWindow.bind("load", connection._.deferredStartHandler);                return deferred.promise();            }            // If we're already connecting just return the same deferral as the original connection start            if (connection.state === signalR.connectionState.connecting) {                return deferred.promise();            } else if (changeState(connection,                            signalR.connectionState.disconnected,                            signalR.connectionState.connecting) === false) {                // We're not connecting so try and transition into connecting.                // If we fail to transition then we're either in connected or reconnecting.                deferred.resolve(connection);                return deferred.promise();            }            configureStopReconnectingTimeout(connection);            // Resolve the full url            parser.href = connection.url;            if (!parser.protocol || parser.protocol === ":") {                connection.protocol = window.document.location.protocol;                connection.host = window.document.location.host;                connection.baseUrl = connection.protocol + "//" + connection.host;            } else {                connection.protocol = parser.protocol;                connection.host = parser.host;                connection.baseUrl = parser.protocol + "//" + parser.host;            }            // Set the websocket protocol            connection.wsProtocol = connection.protocol === "https:" ? "wss://" : "ws://";            // If jsonp with no/auto transport is specified, then set the transport to long polling            // since that is the only transport for which jsonp really makes sense.            // Some developers might actually choose to specify jsonp for same origin requests            // as demonstrated by Issue #623.            if (config.transport === "auto" && config.jsonp === true) {                config.transport = "longPolling";            }            // If the url is protocol relative, prepend the current windows protocol to the url.            if (connection.url.indexOf("//") === 0) {                connection.url = window.location.protocol + connection.url;                connection.log("Protocol relative URL detected, normalizing it to '" + connection.url + "'.");            }            if (this.isCrossDomain(connection.url)) {                connection.log("Auto detected cross domain url.");                if (config.transport === "auto") {                    // TODO: Support XDM with foreverFrame                    config.transport = ["webSockets", "serverSentEvents", "longPolling"];                }                if (typeof (config.withCredentials) === "undefined") {                    config.withCredentials = true;                }                // Determine if jsonp is the only choice for negotiation, ajaxSend and ajaxAbort.                // i.e. if the browser doesn't supports CORS                // If it is, ignore any preference to the contrary, and switch to jsonp.                if (!config.jsonp) {                    config.jsonp = !$.support.cors;                    if (config.jsonp) {                        connection.log("Using jsonp because this browser doesn't support CORS.");                    }                }                connection.contentType = signalR._.defaultContentType;            }            connection.withCredentials = config.withCredentials;            connection.ajaxDataType = config.jsonp ? "jsonp" : "text";            $(connection).bind(events.onStart, function (e, data) {                if ($.type(callback) === "function") {                    callback.call(connection);                }                deferred.resolve(connection);            });            initialize = function (transports, index) {                var noTransportError = signalR._.error(resources.noTransportOnInit);                index = index || 0;                if (index >= transports.length) {                    // No transport initialized successfully                    $(connection).triggerHandler(events.onError, [noTransportError]);                    deferred.reject(noTransportError);                    // Stop the connection if it has connected and move it into the disconnected state                    connection.stop();                    return;                }                // The connection was aborted                if (connection.state === signalR.connectionState.disconnected) {                    return;                }                var transportName = transports[index],                    transport = signalR.transports[transportName],                    initializationComplete = false,                    onFailed = function () {                        // Check if we've already triggered onFailed, onStart                        if (!initializationComplete) {                            initializationComplete = true;                            window.clearTimeout(connection._.onFailedTimeoutHandle);                            transport.stop(connection);                            initialize(transports, index + 1);                        }                    };                connection.transport = transport;                try {                    connection._.onFailedTimeoutHandle = window.setTimeout(function () {                        connection.log(transport.name + " timed out when trying to connect.");                        onFailed();                    }, connection._.totalTransportConnectTimeout);                    transport.start(connection, function () { // success                        // Firefox 11+ doesn't allow sync XHR withCredentials: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#withCredentials                        var isFirefox11OrGreater = signalR._.firefoxMajorVersion(window.navigator.userAgent) >= 11,                            asyncAbort = !!connection.withCredentials && isFirefox11OrGreater;                        // The connection was aborted while initializing transports                        if (connection.state === signalR.connectionState.disconnected) {                            return;                        }                        if (!initializationComplete) {                            initializationComplete = true;                            window.clearTimeout(connection._.onFailedTimeoutHandle);                            if (transport.supportsKeepAlive && connection._.keepAliveData.activated) {                                signalR.transports._logic.monitorKeepAlive(connection);                            }                            signalR.transports._logic.startHeartbeat(connection);                            // Used to ensure low activity clients maintain their authentication.                            // Must be configured once a transport has been decided to perform valid ping requests.                            signalR._.configurePingInterval(connection);                            changeState(connection,                                        signalR.connectionState.connecting,                                        signalR.connectionState.connected);                            // Drain any incoming buffered messages (messages that came in prior to connect)                            connection._.connectingMessageBuffer.drain();                            $(connection).triggerHandler(events.onStart);                            // wire the stop handler for when the user leaves the page                            _pageWindow.bind("unload", function () {                                connection.log("Window unloading, stopping the connection.");                                connection.stop(asyncAbort);                            });                            if (isFirefox11OrGreater) {                                // Firefox does not fire cross-domain XHRs in the normal unload handler on tab close.                                // #2400                                _pageWindow.bind("beforeunload", function () {                                    // If connection.stop() runs runs in beforeunload and fails, it will also fail                                    // in unload unless connection.stop() runs after a timeout.                                    window.setTimeout(function () {                                        connection.stop(asyncAbort);                                    }, 0);                                });                            }                        }                    }, onFailed);                }                catch (error) {                    connection.log(transport.name + " transport threw '" + error.message + "' when attempting to start.");                    onFailed();                }            };            var url = connection.url + "/negotiate",                onFailed = function (error, connection) {                    var err = signalR._.error(resources.errorOnNegotiate, error, connection._.negotiateRequest);                    $(connection).triggerHandler(events.onError, err);                    deferred.reject(err);                    // Stop the connection if negotiate failed                    connection.stop();                };            $(connection).triggerHandler(events.onStarting);            url = signalR.transports._logic.prepareQueryString(connection, url);            // Add the client version to the negotiate request.  We utilize the same addQs method here            // so that it can append the clientVersion appropriately to the URL            url = signalR.transports._logic.addQs(url, {                clientProtocol: connection.clientProtocol            });            connection.log("Negotiating with '" + url + "'.");            // Save the ajax negotiate request object so we can abort it if stop is called while the request is in flight.            connection._.negotiateRequest = $.ajax(                $.extend({}, $.signalR.ajaxDefaults, {                    xhrFields: { withCredentials: connection.withCredentials },                    url: url,                    type: "GET",                    contentType: connection.contentType,                    data: {},                    dataType: connection.ajaxDataType,                    error: function (error, statusText) {                        // We don't want to cause any errors if we're aborting our own negotiate request.                        if (statusText !== _negotiateAbortText) {                            onFailed(error, connection);                        } else {                            // This rejection will noop if the deferred has already been resolved or rejected.                            deferred.reject(signalR._.error(resources.stoppedWhileNegotiating, null /* error */, connection._.negotiateRequest));                        }                    },                    success: function (result) {                        var res,                            keepAliveData,                            protocolError,                            transports = [],                            supportedTransports = [];                        try {                            res = connection._parseResponse(result);                        } catch (error) {                            onFailed(signalR._.error(resources.errorParsingNegotiateResponse, error), connection);                            return;                        }                        keepAliveData = connection._.keepAliveData;                        connection.appRelativeUrl = res.Url;                        connection.id = res.ConnectionId;                        connection.token = res.ConnectionToken;                        connection.webSocketServerUrl = res.WebSocketServerUrl;                        // Once the server has labeled the PersistentConnection as Disconnected, we should stop attempting to reconnect                        // after res.DisconnectTimeout seconds.                        connection.disconnectTimeout = res.DisconnectTimeout * 1000; // in ms                        // Add the TransportConnectTimeout from the response to the transportConnectTimeout from the client to calculate the total timeout                        connection._.totalTransportConnectTimeout = connection.transportConnectTimeout + res.TransportConnectTimeout * 1000;                        // If we have a keep alive                        if (res.KeepAliveTimeout) {                            // Register the keep alive data as activated                            keepAliveData.activated = true;                            // Timeout to designate when to force the connection into reconnecting converted to milliseconds                            keepAliveData.timeout = res.KeepAliveTimeout * 1000;                            // Timeout to designate when to warn the developer that the connection may be dead or is not responding.                            keepAliveData.timeoutWarning = keepAliveData.timeout * connection.keepAliveWarnAt;                            // Instantiate the frequency in which we check the keep alive.  It must be short in order to not miss/pick up any changes                            connection._.beatInterval = (keepAliveData.timeout - keepAliveData.timeoutWarning) / 3;                        } else {                            keepAliveData.activated = false;                        }                        connection.reconnectWindow = connection.disconnectTimeout + (keepAliveData.timeout || 0);                        if (!res.ProtocolVersion || res.ProtocolVersion !== connection.clientProtocol) {                            protocolError = signalR._.error(signalR._.format(resources.protocolIncompatible, connection.clientProtocol, res.ProtocolVersion));                            $(connection).triggerHandler(events.onError, [protocolError]);                            deferred.reject(protocolError);                            return;                        }                        $.each(signalR.transports, function (key) {                            if ((key.indexOf("_") === 0) || (key === "webSockets" && !res.TryWebSockets)) {                                return true;                            }                            supportedTransports.push(key);                        });                        if ($.isArray(config.transport)) {                            $.each(config.transport, function (_, transport) {                                if ($.inArray(transport, supportedTransports) >= 0) {                                    transports.push(transport);                                }                            });                        } else if (config.transport === "auto") {                            transports = supportedTransports;                        } else if ($.inArray(config.transport, supportedTransports) >= 0) {                            transports.push(config.transport);                        }                        initialize(transports);                    }                }            ));            return deferred.promise();        },        starting: function (callback) {            /// <summary>Adds a callback that will be invoked before anything is sent over the connection</summary>            /// <param name="callback" type="Function">A callback function to execute before the connection is fully instantiated.</param>            /// <returns type="signalR" />            var connection = this;            $(connection).bind(events.onStarting, function (e, data) {                callback.call(connection);            });            return connection;        },        send: function (data) {            /// <summary>Sends data over the connection</summary>            /// <param name="data" type="String">The data to send over the connection</param>            /// <returns type="signalR" />            var connection = this;            if (connection.state === signalR.connectionState.disconnected) {                // Connection hasn't been started yet                throw new Error("SignalR: Connection must be started before data can be sent. Call .start() before .send()");            }            if (connection.state === signalR.connectionState.connecting) {                // Connection hasn't been started yet                throw new Error("SignalR: Connection has not been fully initialized. Use .start().done() or .start().fail() to run logic after the connection has started.");            }            connection.transport.send(connection, data);            // REVIEW: Should we return deferred here?            return connection;        },        received: function (callback) {            /// <summary>Adds a callback that will be invoked after anything is received over the connection</summary>            /// <param name="callback" type="Function">A callback function to execute when any data is received on the connection</param>            /// <returns type="signalR" />            var connection = this;            $(connection).bind(events.onReceived, function (e, data) {                callback.call(connection, data);            });            return connection;        },        stateChanged: function (callback) {            /// <summary>Adds a callback that will be invoked when the connection state changes</summary>            /// <param name="callback" type="Function">A callback function to execute when the connection state changes</param>            /// <returns type="signalR" />            var connection = this;            $(connection).bind(events.onStateChanged, function (e, data) {                callback.call(connection, data);            });            return connection;        },        error: function (callback) {            /// <summary>Adds a callback that will be invoked after an error occurs with the connection</summary>            /// <param name="callback" type="Function">A callback function to execute when an error occurs on the connection</param>            /// <returns type="signalR" />            var connection = this;            $(connection).bind(events.onError, function (e, errorData, sendData) {                // In practice 'errorData' is the SignalR built error object.                // In practice 'sendData' is undefined for all error events except those triggered by                // 'ajaxSend' and 'webSockets.send'.'sendData' is the original send payload.                callback.call(connection, errorData, sendData);            });            return connection;        },        disconnected: function (callback) {            /// <summary>Adds a callback that will be invoked when the client disconnects</summary>            /// <param name="callback" type="Function">A callback function to execute when the connection is broken</param>            /// <returns type="signalR" />            var connection = this;            $(connection).bind(events.onDisconnect, function (e, data) {                callback.call(connection);            });            return connection;        },        connectionSlow: function (callback) {            /// <summary>Adds a callback that will be invoked when the client detects a slow connection</summary>            /// <param name="callback" type="Function">A callback function to execute when the connection is slow</param>            /// <returns type="signalR" />            var connection = this;            $(connection).bind(events.onConnectionSlow, function (e, data) {                callback.call(connection);            });            return connection;        },        reconnecting: function (callback) {            /// <summary>Adds a callback that will be invoked when the underlying transport begins reconnecting</summary>            /// <param name="callback" type="Function">A callback function to execute when the connection enters a reconnecting state</param>            /// <returns type="signalR" />            var connection = this;            $(connection).bind(events.onReconnecting, function (e, data) {                callback.call(connection);            });            return connection;        },        reconnected: function (callback) {            /// <summary>Adds a callback that will be invoked when the underlying transport reconnects</summary>            /// <param name="callback" type="Function">A callback function to execute when the connection is restored</param>            /// <returns type="signalR" />            var connection = this;            $(connection).bind(events.onReconnect, function (e, data) {                callback.call(connection);            });            return connection;        },        stop: function (async, notifyServer) {            /// <summary>Stops listening</summary>            /// <param name="async" type="Boolean">Whether or not to asynchronously abort the connection</param>            /// <param name="notifyServer" type="Boolean">Whether we want to notify the server that we are aborting the connection</param>            /// <returns type="signalR" />            var connection = this,                // Save deferral because this is always cleaned up                deferral = connection._deferral;            // Verify that we've bound a load event.            if (connection._.deferredStartHandler) {                // Unbind the event.                _pageWindow.unbind("load", connection._.deferredStartHandler);            }            // Always clean up private non-timeout based state.            delete connection._deferral;            delete connection._.config;            delete connection._.deferredStartHandler;            // This needs to be checked despite the connection state because a connection start can be deferred until page load.            // If we've deferred the start due to a page load we need to unbind the "onLoad" -> start event.            if (!_pageLoaded && (!connection._.config || connection._.config.waitForPageLoad === true)) {                connection.log("Stopping connection prior to negotiate.");                // If we have a deferral we should reject it                if (deferral) {                    deferral.reject(signalR._.error(resources.stoppedWhileLoading));                }                // Short-circuit because the start has not been fully started.                return;            }            if (connection.state === signalR.connectionState.disconnected) {                return;            }            connection.log("Stopping connection.");            changeState(connection, connection.state, signalR.connectionState.disconnected);            // Clear this no matter what            window.clearTimeout(connection._.beatHandle);            window.clearTimeout(connection._.onFailedTimeoutHandle);            window.clearInterval(connection._.pingIntervalId);            if (connection.transport) {                connection.transport.stop(connection);                if (notifyServer !== false) {                    connection.transport.abort(connection, async);                }                if (connection.transport.supportsKeepAlive && connection._.keepAliveData.activated) {                    signalR.transports._logic.stopMonitoringKeepAlive(connection);                }                connection.transport = null;            }            if (connection._.negotiateRequest) {                // If the negotiation request has already completed this will noop.                connection._.negotiateRequest.abort(_negotiateAbortText);                delete connection._.negotiateRequest;            }            // Trigger the disconnect event            $(connection).triggerHandler(events.onDisconnect);            delete connection.messageId;            delete connection.groupsToken;            delete connection.id;            delete connection._.pingIntervalId;            delete connection._.lastMessageAt;            delete connection._.lastActiveAt;            // Clear out our message buffer            connection._.connectingMessageBuffer.clear();            return connection;        },        log: function (msg) {            log(msg, this.logging);        }    };    signalR.fn.init.prototype = signalR.fn;    signalR.noConflict = function () {        /// <summary>Reinstates the original value of $.connection and returns the signalR object for manual assignment</summary>        /// <returns type="signalR" />        if ($.connection === signalR) {            $.connection = _connection;        }        return signalR;    };    if ($.connection) {        _connection = $.connection;    }    $.connection = $.signalR = signalR;}(window.jQuery, window));/* jquery.signalR.transports.common.js */// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.md in the project root for license information./*global window:false *//// <reference path="jquery.signalR.core.js" />(function ($, window, undefined) {    "use strict";    var signalR = $.signalR,        events = $.signalR.events,        changeState = $.signalR.changeState,        transportLogic;    signalR.transports = {};    function beat(connection) {        if (connection._.keepAliveData.monitoring) {            checkIfAlive(connection);        }        // Ensure that we successfully marked active before continuing the heartbeat.        if (transportLogic.markActive(connection)) {            connection._.beatHandle = window.setTimeout(function () {                beat(connection);            }, connection._.beatInterval);        }    }    function checkIfAlive(connection) {        var keepAliveData = connection._.keepAliveData,            timeElapsed;        // Only check if we're connected        if (connection.state === signalR.connectionState.connected) {            timeElapsed = new Date().getTime() - connection._.lastMessageAt;            // Check if the keep alive has completely timed out            if (timeElapsed >= keepAliveData.timeout) {                connection.log("Keep alive timed out.  Notifying transport that connection has been lost.");                // Notify transport that the connection has been lost                connection.transport.lostConnection(connection);            } else if (timeElapsed >= keepAliveData.timeoutWarning) {                // This is to assure that the user only gets a single warning                if (!keepAliveData.userNotified) {                    connection.log("Keep alive has been missed, connection may be dead/slow.");                    $(connection).triggerHandler(events.onConnectionSlow);                    keepAliveData.userNotified = true;                }            } else {                keepAliveData.userNotified = false;            }        }    }    function addConnectionData(url, connectionData) {        var appender = url.indexOf("?") !== -1 ? "&" : "?";        if (connectionData) {            url += appender + "connectionData=" + window.encodeURIComponent(connectionData);        }        return url;    }    transportLogic = signalR.transports._logic = {        pingServer: function (connection) {            /// <summary>Pings the server</summary>            /// <param name="connection" type="signalr">Connection associated with the server ping</param>            /// <returns type="signalR" />            var url, deferral = $.Deferred(), xhr;            if (connection.transport) {                url = connection.url + "/ping";                url = transportLogic.addQs(url, connection.qs);                xhr = $.ajax(                    $.extend({}, $.signalR.ajaxDefaults, {                        xhrFields: { withCredentials: connection.withCredentials },                        url: url,                        type: "GET",                        contentType: connection.contentType,                        data: {},                        dataType: connection.ajaxDataType,                        success: function (result) {                            var data;                            try {                                data = connection._parseResponse(result);                            }                            catch (error) {                                deferral.reject(                                    signalR._.transportError(                                        signalR.resources.pingServerFailedParse,                                        connection.transport,                                        error,                                        xhr                                    )                                );                                connection.stop();                                return;                            }                            if (data.Response === "pong") {                                deferral.resolve();                            }                            else {                                deferral.reject(                                    signalR._.transportError(                                        signalR._.format(signalR.resources.pingServerFailedInvalidResponse, result.responseText),                                        connection.transport,                                        null /* error */,                                        xhr                                    )                                );                            }                        },                        error: function (error) {                            if (error.status === 401 || error.status === 403) {                                deferral.reject(                                    signalR._.transportError(                                        signalR._.format(signalR.resources.pingServerFailedStatusCode, error.status),                                        connection.transport,                                        error,                                        xhr                                    )                                );                                connection.stop();                            }                            else {                                deferral.reject(                                    signalR._.transportError(                                        signalR.resources.pingServerFailed,                                        connection.transport,                                        error,                                        xhr                                    )                                );                            }                        }                    }                ));            }            else {                deferral.reject(                    signalR._.transportError(                        signalR.resources.noConnectionTransport,                        connection.transport                    )                );            }            return deferral.promise();        },        prepareQueryString: function (connection, url) {            url = transportLogic.addQs(url, connection.qs);            return addConnectionData(url, connection.data);        },        addQs: function (url, qs) {            var appender = url.indexOf("?") !== -1 ? "&" : "?",                firstChar;            if (!qs) {                return url;            }            if (typeof (qs) === "object") {                return url + appender + $.param(qs);            }            if (typeof (qs) === "string") {                firstChar = qs.charAt(0);                if (firstChar === "?" || firstChar === "&") {                    appender = "";                }                return url + appender + qs;            }            throw new Error("Query string property must be either a string or object.");        },        getUrl: function (connection, transport, reconnecting, poll) {            /// <summary>Gets the url for making a GET based connect request</summary>            var baseUrl = transport === "webSockets" ? "" : connection.baseUrl,                url = baseUrl + connection.appRelativeUrl,                qs = "transport=" + transport + "&connectionToken=" + window.encodeURIComponent(connection.token);            if (connection.groupsToken) {                qs += "&groupsToken=" + window.encodeURIComponent(connection.groupsToken);            }            if (!reconnecting) {                url += "/connect";            } else {                if (poll) {                    // longPolling transport specific                    url += "/poll";                } else {                    url += "/reconnect";                }                if (connection.messageId) {                    qs += "&messageId=" + window.encodeURIComponent(connection.messageId);                }            }            url += "?" + qs;            url = transportLogic.prepareQueryString(connection, url);            url += "&tid=" + Math.floor(Math.random() * 11);            return url;        },        maximizePersistentResponse: function (minPersistentResponse) {            return {                MessageId: minPersistentResponse.C,                Messages: minPersistentResponse.M,                Initialized: typeof (minPersistentResponse.S) !== "undefined" ? true : false,                Disconnect: typeof (minPersistentResponse.D) !== "undefined" ? true : false,                ShouldReconnect: typeof (minPersistentResponse.T) !== "undefined" ? true : false,                LongPollDelay: minPersistentResponse.L,                GroupsToken: minPersistentResponse.G            };        },        updateGroups: function (connection, groupsToken) {            if (groupsToken) {                connection.groupsToken = groupsToken;            }        },        stringifySend: function (connection, message) {            if (typeof (message) === "string" || typeof (message) === "undefined" || message === null) {                return message;            }            return connection.json.stringify(message);        },        ajaxSend: function (connection, data) {            var payload = transportLogic.stringifySend(connection, data),                url = connection.url + "/send" + "?transport=" + connection.transport.name + "&connectionToken=" + window.encodeURIComponent(connection.token),                xhr,                onFail = function (error, connection) {                    $(connection).triggerHandler(events.onError, [signalR._.transportError(signalR.resources.sendFailed, connection.transport, error, xhr), data]);                };            url = transportLogic.prepareQueryString(connection, url);            xhr = $.ajax(                $.extend({}, $.signalR.ajaxDefaults, {                    xhrFields: { withCredentials: connection.withCredentials },                    url: url,                    type: connection.ajaxDataType === "jsonp" ? "GET" : "POST",                    contentType: signalR._.defaultContentType,                    dataType: connection.ajaxDataType,                    data: {                        data: payload                    },                    success: function (result) {                        var res;                        if (result) {                            try {                                res = connection._parseResponse(result);                            }                            catch (error) {                                onFail(error, connection);                                connection.stop();                                return;                            }                            transportLogic.triggerReceived(connection, res);                        }                    },                    error: function (error, textStatus) {                        if (textStatus === "abort" || textStatus === "parsererror") {                            // The parsererror happens for sends that don't return any data, and hence                            // don't write the jsonp callback to the response. This is harder to fix on the server                            // so just hack around it on the client for now.                            return;                        }                        onFail(error, connection);                    }                }            ));            return xhr;        },        ajaxAbort: function (connection, async) {            if (typeof (connection.transport) === "undefined") {                return;            }            // Async by default unless explicitly overidden            async = typeof async === "undefined" ? true : async;            var url = connection.url + "/abort" + "?transport=" + connection.transport.name + "&connectionToken=" + window.encodeURIComponent(connection.token);            url = transportLogic.prepareQueryString(connection, url);            $.ajax(                $.extend({}, $.signalR.ajaxDefaults, {                    xhrFields: { withCredentials: connection.withCredentials },                    url: url,                    async: async,                    timeout: 1000,                    type: "POST",                    contentType: connection.contentType,                    dataType: connection.ajaxDataType,                    data: {}                }            ));            connection.log("Fired ajax abort async = " + async + ".");        },        tryInitialize: function (persistentResponse, onInitialized) {            if (persistentResponse.Initialized) {                onInitialized();            }        },        triggerReceived: function (connection, data) {            if (!connection._.connectingMessageBuffer.tryBuffer(data)) {                $(connection).triggerHandler(events.onReceived, [data]);            }        },        processMessages: function (connection, minData, onInitialized) {            var data;            // Update the last message time stamp            transportLogic.markLastMessage(connection);            if (minData) {                data = transportLogic.maximizePersistentResponse(minData);                if (data.Disconnect) {                    connection.log("Disconnect command received from server.");                    // Disconnected by the server                    connection.stop(false, false);                    return;                }                transportLogic.updateGroups(connection, data.GroupsToken);                if (data.MessageId) {                    connection.messageId = data.MessageId;                }                if (data.Messages) {                    $.each(data.Messages, function (index, message) {                        transportLogic.triggerReceived(connection, message);                    });                    transportLogic.tryInitialize(data, onInitialized);                }            }        },        monitorKeepAlive: function (connection) {            var keepAliveData = connection._.keepAliveData;            // If we haven't initiated the keep alive timeouts then we need to            if (!keepAliveData.monitoring) {                keepAliveData.monitoring = true;                transportLogic.markLastMessage(connection);                // Save the function so we can unbind it on stop                connection._.keepAliveData.reconnectKeepAliveUpdate = function () {                    // Mark a new message so that keep alive doesn't time out connections                    transportLogic.markLastMessage(connection);                };                // Update Keep alive on reconnect                $(connection).bind(events.onReconnect, connection._.keepAliveData.reconnectKeepAliveUpdate);                connection.log("Now monitoring keep alive with a warning timeout of " + keepAliveData.timeoutWarning + " and a connection lost timeout of " + keepAliveData.timeout + ".");            } else {                connection.log("Tried to monitor keep alive but it's already being monitored.");            }        },        stopMonitoringKeepAlive: function (connection) {            var keepAliveData = connection._.keepAliveData;            // Only attempt to stop the keep alive monitoring if its being monitored            if (keepAliveData.monitoring) {                // Stop monitoring                keepAliveData.monitoring = false;                // Remove the updateKeepAlive function from the reconnect event                $(connection).unbind(events.onReconnect, connection._.keepAliveData.reconnectKeepAliveUpdate);                // Clear all the keep alive data                connection._.keepAliveData = {};                connection.log("Stopping the monitoring of the keep alive.");            }        },        startHeartbeat: function (connection) {            connection._.lastActiveAt = new Date().getTime();            beat(connection);        },        markLastMessage: function (connection) {            connection._.lastMessageAt = new Date().getTime();        },        markActive: function (connection) {            if (transportLogic.verifyLastActive(connection)) {                connection._.lastActiveAt = new Date().getTime();                return true;            }            return false;        },        isConnectedOrReconnecting: function (connection) {            return connection.state === signalR.connectionState.connected ||                   connection.state === signalR.connectionState.reconnecting;        },        ensureReconnectingState: function (connection) {            if (changeState(connection,                        signalR.connectionState.connected,                        signalR.connectionState.reconnecting) === true) {                $(connection).triggerHandler(events.onReconnecting);            }            return connection.state === signalR.connectionState.reconnecting;        },        clearReconnectTimeout: function (connection) {            if (connection && connection._.reconnectTimeout) {                window.clearTimeout(connection._.reconnectTimeout);                delete connection._.reconnectTimeout;            }        },        verifyLastActive: function (connection) {            if (new Date().getTime() - connection._.lastActiveAt >= connection.reconnectWindow) {                connection.log("There has not been an active server connection for an extended period of time. Stopping connection.");                connection.stop();                return false;            }            return true;        },        reconnect: function (connection, transportName) {            var transport = signalR.transports[transportName];            // We should only set a reconnectTimeout if we are currently connected            // and a reconnectTimeout isn't already set.            if (transportLogic.isConnectedOrReconnecting(connection) && !connection._.reconnectTimeout) {                // Need to verify before the setTimeout occurs because an application sleep could occur during the setTimeout duration.                if (!transportLogic.verifyLastActive(connection)) {                    return;                }                connection._.reconnectTimeout = window.setTimeout(function () {                    if (!transportLogic.verifyLastActive(connection)) {                        return;                    }                    transport.stop(connection);                    if (transportLogic.ensureReconnectingState(connection)) {                        connection.log(transportName + " reconnecting.");                        transport.start(connection);                    }                }, connection.reconnectDelay);            }        },        handleParseFailure: function (connection, result, error, onFailed, context) {            // If we're in the initialization phase trigger onFailed, otherwise stop the connection.            if (connection.state === signalR.connectionState.connecting) {                connection.log("Failed to parse server response while attempting to connect.");                onFailed();            } else {                $(connection).triggerHandler(events.onError, [                    signalR._.transportError(                        signalR._.format(signalR.resources.parseFailed, result),                        connection.transport,                        error,                        context)]);                connection.stop();            }        },        foreverFrame: {            count: 0,            connections: {}        }    };}(window.jQuery, window));/* jquery.signalR.transports.webSockets.js */// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.md in the project root for license information./*global window:false *//// <reference path="jquery.signalR.transports.common.js" />(function ($, window, undefined) {    "use strict";    var signalR = $.signalR,        events = $.signalR.events,        changeState = $.signalR.changeState,        transportLogic = signalR.transports._logic;    signalR.transports.webSockets = {        name: "webSockets",        supportsKeepAlive: true,        send: function (connection, data) {            var payload = transportLogic.stringifySend(connection, data);            try {                connection.socket.send(payload);            } catch (ex) {                $(connection).triggerHandler(events.onError,                    [signalR._.transportError(                        signalR.resources.webSocketsInvalidState,                        connection.transport,                        ex,                        connection.socket                    ),                    data]);            }        },        start: function (connection, onSuccess, onFailed) {            var url,                opened = false,                that = this,                reconnecting = !onSuccess,                $connection = $(connection);            if (!window.WebSocket) {                onFailed();                return;            }            if (!connection.socket) {                if (connection.webSocketServerUrl) {                    url = connection.webSocketServerUrl;                } else {                    url = connection.wsProtocol + connection.host;                }                url += transportLogic.getUrl(connection, this.name, reconnecting);                connection.log("Connecting to websocket endpoint '" + url + "'.");                connection.socket = new window.WebSocket(url);                connection.socket.onopen = function () {                    opened = true;                    connection.log("Websocket opened.");                    transportLogic.clearReconnectTimeout(connection);                    if (changeState(connection,                                    signalR.connectionState.reconnecting,                                    signalR.connectionState.connected) === true) {                        $connection.triggerHandler(events.onReconnect);                    }                };                connection.socket.onclose = function (event) {                    // Only handle a socket close if the close is from the current socket.                    // Sometimes on disconnect the server will push down an onclose event                    // to an expired socket.                    if (this === connection.socket) {                        if (!opened) {                            if (onFailed) {                                onFailed();                            } else if (reconnecting) {                                that.reconnect(connection);                            }                            return;                        } else if (typeof event.wasClean !== "undefined" && event.wasClean === false) {                            // Ideally this would use the websocket.onerror handler (rather than checking wasClean in onclose) but                            // I found in some circumstances Chrome won't call onerror. This implementation seems to work on all browsers.                            $(connection).triggerHandler(events.onError, [signalR._.transportError(                                signalR.resources.webSocketClosed,                                connection.transport,                                event)]);                            connection.log("Unclean disconnect from websocket: " + event.reason || "[no reason given].");                        } else {                            connection.log("Websocket closed.");                        }                        that.reconnect(connection);                    }                };                connection.socket.onmessage = function (event) {                    var data;                    try {                        data = connection._parseResponse(event.data);                    }                    catch (error) {                        transportLogic.handleParseFailure(connection, event.data, error, onFailed, event);                        return;                    }                    if (data) {                        // data.M is PersistentResponse.Messages                        if ($.isEmptyObject(data) || data.M) {                            transportLogic.processMessages(connection, data, onSuccess);                        } else {                            // For websockets we need to trigger onReceived                            // for callbacks to outgoing hub calls.                            transportLogic.triggerReceived(connection, data);                        }                    }                };            }        },        reconnect: function (connection) {            transportLogic.reconnect(connection, this.name);        },        lostConnection: function (connection) {            this.reconnect(connection);        },        stop: function (connection) {            // Don't trigger a reconnect after stopping            transportLogic.clearReconnectTimeout(connection);            if (connection.socket) {                connection.log("Closing the Websocket.");                connection.socket.close();                connection.socket = null;            }        },        abort: function (connection, async) {            transportLogic.ajaxAbort(connection, async);        }    };}(window.jQuery, window));/* jquery.signalR.transports.serverSentEvents.js */// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.md in the project root for license information./*global window:false *//// <reference path="jquery.signalR.transports.common.js" />(function ($, window, undefined) {    "use strict";    var signalR = $.signalR,        events = $.signalR.events,        changeState = $.signalR.changeState,        transportLogic = signalR.transports._logic;    signalR.transports.serverSentEvents = {        name: "serverSentEvents",        supportsKeepAlive: true,        timeOut: 3000,        start: function (connection, onSuccess, onFailed) {            var that = this,                opened = false,                $connection = $(connection),                reconnecting = !onSuccess,                url,                reconnectTimeout;            if (connection.eventSource) {                connection.log("The connection already has an event source. Stopping it.");                connection.stop();            }            if (!window.EventSource) {                if (onFailed) {                    connection.log("This browser doesn't support SSE.");                    onFailed();                }                return;            }            url = transportLogic.getUrl(connection, this.name, reconnecting);            try {                connection.log("Attempting to connect to SSE endpoint '" + url + "'.");                connection.eventSource = new window.EventSource(url, { withCredentials: connection.withCredentials });            }            catch (e) {                connection.log("EventSource failed trying to connect with error " + e.Message + ".");                if (onFailed) {                    // The connection failed, call the failed callback                    onFailed();                } else {                    $connection.triggerHandler(events.onError, [signalR._.transportError(signalR.resources.eventSourceFailedToConnect, connection.transport, e)]);                    if (reconnecting) {                        // If we were reconnecting, rather than doing initial connect, then try reconnect again                        that.reconnect(connection);                    }                }                return;            }            if (reconnecting) {                reconnectTimeout = window.setTimeout(function () {                    if (opened === false) {                        // If we're reconnecting and the event source is attempting to connect,                        // don't keep retrying. This causes duplicate connections to spawn.                        if (connection.eventSource.readyState !== window.EventSource.OPEN) {                            // If we were reconnecting, rather than doing initial connect, then try reconnect again                            that.reconnect(connection);                        }                    }                },                that.timeOut);            }            connection.eventSource.addEventListener("open", function (e) {                connection.log("EventSource connected.");                if (reconnectTimeout) {                    window.clearTimeout(reconnectTimeout);                }                transportLogic.clearReconnectTimeout(connection);                if (opened === false) {                    opened = true;                    if (changeState(connection,                                         signalR.connectionState.reconnecting,                                         signalR.connectionState.connected) === true) {                        $connection.triggerHandler(events.onReconnect);                    }                }            }, false);            connection.eventSource.addEventListener("message", function (e) {                var res;                // process messages                if (e.data === "initialized") {                    return;                }                try {                    res = connection._parseResponse(e.data);                }                catch (error) {                    transportLogic.handleParseFailure(connection, e.data, error, onFailed, e);                    return;                }                transportLogic.processMessages(connection, res, onSuccess);            }, false);            connection.eventSource.addEventListener("error", function (e) {                // Only handle an error if the error is from the current Event Source.                // Sometimes on disconnect the server will push down an error event                // to an expired Event Source.                if (this !== connection.eventSource) {                    return;                }                if (!opened) {                    if (onFailed) {                        onFailed();                    }                    return;                }                connection.log("EventSource readyState: " + connection.eventSource.readyState + ".");                if (e.eventPhase === window.EventSource.CLOSED) {                    // We don't use the EventSource's native reconnect function as it                    // doesn't allow us to change the URL when reconnecting. We need                    // to change the URL to not include the /connect suffix, and pass                    // the last message id we received.                    connection.log("EventSource reconnecting due to the server connection ending.");                    that.reconnect(connection);                } else {                    // connection error                    connection.log("EventSource error.");                    $connection.triggerHandler(events.onError, [signalR._.transportError(signalR.resources.eventSourceError, connection.transport, e)]);                }            }, false);        },        reconnect: function (connection) {            transportLogic.reconnect(connection, this.name);        },        lostConnection: function (connection) {            this.reconnect(connection);        },        send: function (connection, data) {            transportLogic.ajaxSend(connection, data);        },        stop: function (connection) {            // Don't trigger a reconnect after stopping            transportLogic.clearReconnectTimeout(connection);            if (connection && connection.eventSource) {                connection.log("EventSource calling close().");                connection.eventSource.close();                connection.eventSource = null;                delete connection.eventSource;            }        },        abort: function (connection, async) {            transportLogic.ajaxAbort(connection, async);        }    };}(window.jQuery, window));/* jquery.signalR.transports.foreverFrame.js */// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.md in the project root for license information./*global window:false *//// <reference path="jquery.signalR.transports.common.js" />(function ($, window, undefined) {    "use strict";    var signalR = $.signalR,        events = $.signalR.events,        changeState = $.signalR.changeState,        transportLogic = signalR.transports._logic,        createFrame = function () {            var frame = window.document.createElement("iframe");            frame.setAttribute("style", "position:absolute;top:0;left:0;width:0;height:0;visibility:hidden;");            return frame;        },        // Used to prevent infinite loading icon spins in older versions of ie        // We build this object inside a closure so we don't pollute the rest of        // the foreverFrame transport with unnecessary functions/utilities.        loadPreventer = (function () {            var loadingFixIntervalId = null,                loadingFixInterval = 1000,                attachedTo = 0;            return {                prevent: function () {                    // Prevent additional iframe removal procedures from newer browsers                    if (signalR._.ieVersion <= 8) {                        // We only ever want to set the interval one time, so on the first attachedTo                        if (attachedTo === 0) {                            // Create and destroy iframe every 3 seconds to prevent loading icon, super hacky                            loadingFixIntervalId = window.setInterval(function () {                                var tempFrame = createFrame();                                window.document.body.appendChild(tempFrame);                                window.document.body.removeChild(tempFrame);                                tempFrame = null;                            }, loadingFixInterval);                        }                        attachedTo++;                    }                },                cancel: function () {                    // Only clear the interval if there's only one more object that the loadPreventer is attachedTo                    if (attachedTo === 1) {                        window.clearInterval(loadingFixIntervalId);                    }                    if (attachedTo > 0) {                        attachedTo--;                    }                }            };        })();    signalR.transports.foreverFrame = {        name: "foreverFrame",        supportsKeepAlive: true,        // Added as a value here so we can create tests to verify functionality        iframeClearThreshold: 50,        start: function (connection, onSuccess, onFailed) {            var that = this,                frameId = (transportLogic.foreverFrame.count += 1),                url,                frame = createFrame(),                frameLoadHandler = function () {                    connection.log("Forever frame iframe finished loading and is no longer receiving messages.");                    that.reconnect(connection);                };            if (window.EventSource) {                // If the browser supports SSE, don't use Forever Frame                if (onFailed) {                    connection.log("This browser supports SSE, skipping Forever Frame.");                    onFailed();                }                return;            }            frame.setAttribute("data-signalr-connection-id", connection.id);            // Start preventing loading icon            // This will only perform work if the loadPreventer is not attached to another connection.            loadPreventer.prevent();            // Build the url            url = transportLogic.getUrl(connection, this.name);            url += "&frameId=" + frameId;            // Set body prior to setting URL to avoid caching issues.            window.document.body.appendChild(frame);            connection.log("Binding to iframe's load event.");            if (frame.addEventListener) {                frame.addEventListener("load", frameLoadHandler, false);            } else if (frame.attachEvent) {                frame.attachEvent("onload", frameLoadHandler);            }            frame.src = url;            transportLogic.foreverFrame.connections[frameId] = connection;            connection.frame = frame;            connection.frameId = frameId;            if (onSuccess) {                connection.onSuccess = function () {                    connection.log("Iframe transport started.");                    onSuccess();                };            }        },        reconnect: function (connection) {            var that = this;            // Need to verify connection state and verify before the setTimeout occurs because an application sleep could occur during the setTimeout duration.            if (transportLogic.isConnectedOrReconnecting(connection) && transportLogic.verifyLastActive(connection)) {                window.setTimeout(function () {                    // Verify that we're ok to reconnect.                    if (!transportLogic.verifyLastActive(connection)) {                        return;                    }                    if (connection.frame && transportLogic.ensureReconnectingState(connection)) {                        var frame = connection.frame,                            src = transportLogic.getUrl(connection, that.name, true) + "&frameId=" + connection.frameId;                        connection.log("Updating iframe src to '" + src + "'.");                        frame.src = src;                    }                }, connection.reconnectDelay);            }        },        lostConnection: function (connection) {            this.reconnect(connection);        },        send: function (connection, data) {            transportLogic.ajaxSend(connection, data);        },        receive: function (connection, data) {            var cw,                body;            transportLogic.processMessages(connection, data, connection.onSuccess);            // Protect against connection stopping from a callback trigger within the processMessages above.            if (connection.state === $.signalR.connectionState.connected) {                // Delete the script & div elements                connection.frameMessageCount = (connection.frameMessageCount || 0) + 1;                if (connection.frameMessageCount > signalR.transports.foreverFrame.iframeClearThreshold) {                    connection.frameMessageCount = 0;                    cw = connection.frame.contentWindow || connection.frame.contentDocument;                    if (cw && cw.document && cw.document.body) {                        body = cw.document.body;                        // Remove all the child elements from the iframe's body to conserver memory                        while (body.firstChild) {                            body.removeChild(body.firstChild);                        }                    }                }            }        },        stop: function (connection) {            var cw = null;            // Stop attempting to prevent loading icon            loadPreventer.cancel();            if (connection.frame) {                if (connection.frame.stop) {                    connection.frame.stop();                } else {                    try {                        cw = connection.frame.contentWindow || connection.frame.contentDocument;                        if (cw.document && cw.document.execCommand) {                            cw.document.execCommand("Stop");                        }                    }                    catch (e) {                        connection.log("Error occured when stopping foreverFrame transport. Message = " + e.message + ".");                    }                }                // Ensure the iframe is where we left it                if (connection.frame.parentNode === window.document.body) {                    window.document.body.removeChild(connection.frame);                }                delete transportLogic.foreverFrame.connections[connection.frameId];                connection.frame = null;                connection.frameId = null;                delete connection.frame;                delete connection.frameId;                delete connection.onSuccess;                delete connection.frameMessageCount;                connection.log("Stopping forever frame.");            }        },        abort: function (connection, async) {            transportLogic.ajaxAbort(connection, async);        },        getConnection: function (id) {            return transportLogic.foreverFrame.connections[id];        },        started: function (connection) {            if (changeState(connection,                signalR.connectionState.reconnecting,                signalR.connectionState.connected) === true) {                // If there's no onSuccess handler we assume this is a reconnect                $(connection).triggerHandler(events.onReconnect);            }        }    };}(window.jQuery, window));/* jquery.signalR.transports.longPolling.js */// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.md in the project root for license information./*global window:false *//// <reference path="jquery.signalR.transports.common.js" />(function ($, window, undefined) {    "use strict";    var signalR = $.signalR,        events = $.signalR.events,        changeState = $.signalR.changeState,        isDisconnecting = $.signalR.isDisconnecting,        transportLogic = signalR.transports._logic;    signalR.transports.longPolling = {        name: "longPolling",        supportsKeepAlive: false,        reconnectDelay: 3000,        start: function (connection, onSuccess, onFailed) {            /// <summary>Starts the long polling connection</summary>            /// <param name="connection" type="signalR">The SignalR connection to start</param>            var that = this,                fireConnect = function () {                    fireConnect = $.noop;                    connection.log("LongPolling connected.");                    onSuccess();                    // Reset onFailed to null because it shouldn't be called again                    onFailed = null;                },                tryFailConnect = function () {                    if (onFailed) {                        onFailed();                        onFailed = null;                        connection.log("LongPolling failed to connect.");                        return true;                    }                    return false;                },                privateData = connection._,                reconnectErrors = 0,                fireReconnected = function (instance) {                    window.clearTimeout(privateData.reconnectTimeoutId);                    privateData.reconnectTimeoutId = null;                    if (changeState(instance,                                    signalR.connectionState.reconnecting,                                    signalR.connectionState.connected) === true) {                        // Successfully reconnected!                        instance.log("Raising the reconnect event");                        $(instance).triggerHandler(events.onReconnect);                    }                },                // 1 hour                maxFireReconnectedTimeout = 3600000;            if (connection.pollXhr) {                connection.log("Polling xhr requests already exists, aborting.");                connection.stop();            }            connection.messageId = null;            privateData.reconnectTimeoutId = null;            privateData.pollTimeoutId = window.setTimeout(function () {                (function poll(instance, raiseReconnect) {                    var messageId = instance.messageId,                        connect = (messageId === null),                        reconnecting = !connect,                        polling = !raiseReconnect,                        url = transportLogic.getUrl(instance, that.name, reconnecting, polling);                    // If we've disconnected during the time we've tried to re-instantiate the poll then stop.                    if (isDisconnecting(instance) === true) {                        return;                    }                    connection.log("Opening long polling request to '" + url + "'.");                    instance.pollXhr = $.ajax(                        $.extend({}, $.signalR.ajaxDefaults, {                            xhrFields: { withCredentials: connection.withCredentials },                            url: url,                            type: "GET",                            dataType: connection.ajaxDataType,                            contentType: connection.contentType,                            success: function (result) {                                var minData,                                    delay = 0,                                    data,                                    shouldReconnect;                                connection.log("Long poll complete.");                                // Reset our reconnect errors so if we transition into a reconnecting state again we trigger                                // reconnected quickly                                reconnectErrors = 0;                                try {                                    minData = connection._parseResponse(result);                                }                                catch (error) {                                    transportLogic.handleParseFailure(instance, result, error, tryFailConnect, instance.pollXhr);                                    return;                                }                                // If there's currently a timeout to trigger reconnect, fire it now before processing messages                                if (privateData.reconnectTimeoutId !== null) {                                    fireReconnected(instance);                                }                                if (minData) {                                    data = transportLogic.maximizePersistentResponse(minData);                                }                                transportLogic.processMessages(instance, minData, fireConnect);                                if (data &&                                    $.type(data.LongPollDelay) === "number") {                                    delay = data.LongPollDelay;                                }                                if (data && data.Disconnect) {                                    return;                                }                                if (isDisconnecting(instance) === true) {                                    return;                                }                                shouldReconnect = data && data.ShouldReconnect;                                if (shouldReconnect) {                                    // Transition into the reconnecting state                                    // If this fails then that means that the user transitioned the connection into a invalid state in processMessages.                                    if (!transportLogic.ensureReconnectingState(instance)) {                                        return;                                    }                                }                                // We never want to pass a raiseReconnect flag after a successful poll.  This is handled via the error function                                if (delay > 0) {                                    privateData.pollTimeoutId = window.setTimeout(function () {                                        poll(instance, shouldReconnect);                                    }, delay);                                } else {                                    poll(instance, shouldReconnect);                                }                            },                            error: function (data, textStatus) {                                // Stop trying to trigger reconnect, connection is in an error state                                // If we're not in the reconnect state this will noop                                window.clearTimeout(privateData.reconnectTimeoutId);                                privateData.reconnectTimeoutId = null;                                if (textStatus === "abort") {                                    connection.log("Aborted xhr request.");                                    return;                                }                                if (!tryFailConnect()) {                                    // Increment our reconnect errors, we assume all errors to be reconnect errors                                    // In the case that it's our first error this will cause Reconnect to be fired                                    // after 1 second due to reconnectErrors being = 1.                                    reconnectErrors++;                                    if (connection.state !== signalR.connectionState.reconnecting) {                                        connection.log("An error occurred using longPolling. Status = " + textStatus + ".  Response = " + data.responseText + ".");                                        $(instance).triggerHandler(events.onError, [signalR._.transportError(signalR.resources.longPollFailed, connection.transport, data, instance.pollXhr)]);                                    }                                    // We check the state here to verify that we're not in an invalid state prior to verifying Reconnect.                                    // If we're not in connected or reconnecting then the next ensureReconnectingState check will fail and will return.                                    // Therefore we don't want to change that failure code path.                                    if ((connection.state === signalR.connectionState.connected ||                                        connection.state === signalR.connectionState.reconnecting) &&                                        !transportLogic.verifyLastActive(connection)) {                                        return;                                    }                                    // Transition into the reconnecting state                                    // If this fails then that means that the user transitioned the connection into the disconnected or connecting state within the above error handler trigger.                                    if (!transportLogic.ensureReconnectingState(instance)) {                                        return;                                    }                                    // Call poll with the raiseReconnect flag as true after the reconnect delay                                    privateData.pollTimeoutId = window.setTimeout(function () {                                        poll(instance, true);                                    }, that.reconnectDelay);                                }                            }                        }                    ));                    // This will only ever pass after an error has occured via the poll ajax procedure.                    if (reconnecting && raiseReconnect === true) {                        // We wait to reconnect depending on how many times we've failed to reconnect.                        // This is essentially a heuristic that will exponentially increase in wait time before                        // triggering reconnected.  This depends on the "error" handler of Poll to cancel this                        // timeout if it triggers before the Reconnected event fires.                        // The Math.min at the end is to ensure that the reconnect timeout does not overflow.                        privateData.reconnectTimeoutId = window.setTimeout(function () { fireReconnected(instance); }, Math.min(1000 * (Math.pow(2, reconnectErrors) - 1), maxFireReconnectedTimeout));                    }                }(connection));            }, 250); // Have to delay initial poll so Chrome doesn't show loader spinner in tab        },        lostConnection: function (connection) {            throw new Error("Lost Connection not handled for LongPolling");        },        send: function (connection, data) {            transportLogic.ajaxSend(connection, data);        },        stop: function (connection) {            /// <summary>Stops the long polling connection</summary>            /// <param name="connection" type="signalR">The SignalR connection to stop</param>            window.clearTimeout(connection._.pollTimeoutId);            window.clearTimeout(connection._.reconnectTimeoutId);            delete connection._.pollTimeoutId;            delete connection._.reconnectTimeoutId;            if (connection.pollXhr) {                connection.pollXhr.abort();                connection.pollXhr = null;                delete connection.pollXhr;            }        },        abort: function (connection, async) {            transportLogic.ajaxAbort(connection, async);        }    };}(window.jQuery, window));/* jquery.signalR.hubs.js */// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.md in the project root for license information./*global window:false *//// <reference path="jquery.signalR.core.js" />(function ($, window, undefined) {    "use strict";    var eventNamespace = ".hubProxy",        signalR = $.signalR;    function makeEventName(event) {        return event + eventNamespace;    }    // Equivalent to Array.prototype.map    function map(arr, fun, thisp) {        var i,            length = arr.length,            result = [];        for (i = 0; i < length; i += 1) {            if (arr.hasOwnProperty(i)) {                result[i] = fun.call(thisp, arr[i], i, arr);            }        }        return result;    }    function getArgValue(a) {        return $.isFunction(a) ? null : ($.type(a) === "undefined" ? null : a);    }    function hasMembers(obj) {        for (var key in obj) {            // If we have any properties in our callback map then we have callbacks and can exit the loop via return            if (obj.hasOwnProperty(key)) {                return true;            }        }        return false;    }    function clearInvocationCallbacks(connection, error) {        /// <param name="connection" type="hubConnection" />        var callbacks = connection._.invocationCallbacks,            callback;        if (hasMembers(callbacks)) {            connection.log("Clearing hub invocation callbacks with error: " + error + ".");        }        // Reset the callback cache now as we have a local var referencing it        connection._.invocationCallbackId = 0;        delete connection._.invocationCallbacks;        connection._.invocationCallbacks = {};        // Loop over the callbacks and invoke them.        // We do this using a local var reference and *after* we've cleared the cache        // so that if a fail callback itself tries to invoke another method we don't        // end up with its callback in the list we're looping over.        for (var callbackId in callbacks) {            callback = callbacks[callbackId];            callback.method.call(callback.scope, { E: error });        }    }    // hubProxy    function hubProxy(hubConnection, hubName) {        /// <summary>        ///     Creates a new proxy object for the given hub connection that can be used to invoke        ///     methods on server hubs and handle client method invocation requests from the server.        /// </summary>        return new hubProxy.fn.init(hubConnection, hubName);    }    hubProxy.fn = hubProxy.prototype = {        init: function (connection, hubName) {            this.state = {};            this.connection = connection;            this.hubName = hubName;            this._ = {                callbackMap: {}            };        },        hasSubscriptions: function () {            return hasMembers(this._.callbackMap);        },        on: function (eventName, callback) {            /// <summary>Wires up a callback to be invoked when a invocation request is received from the server hub.</summary>            /// <param name="eventName" type="String">The name of the hub event to register the callback for.</param>            /// <param name="callback" type="Function">The callback to be invoked.</param>            var that = this,                callbackMap = that._.callbackMap;            // Normalize the event name to lowercase            eventName = eventName.toLowerCase();            // If there is not an event registered for this callback yet we want to create its event space in the callback map.            if (!callbackMap[eventName]) {                callbackMap[eventName] = {};            }            // Map the callback to our encompassed function            callbackMap[eventName][callback] = function (e, data) {                callback.apply(that, data);            };            $(that).bind(makeEventName(eventName), callbackMap[eventName][callback]);            return that;        },        off: function (eventName, callback) {            /// <summary>Removes the callback invocation request from the server hub for the given event name.</summary>            /// <param name="eventName" type="String">The name of the hub event to unregister the callback for.</param>            /// <param name="callback" type="Function">The callback to be invoked.</param>            var that = this,                callbackMap = that._.callbackMap,                callbackSpace;            // Normalize the event name to lowercase            eventName = eventName.toLowerCase();            callbackSpace = callbackMap[eventName];            // Verify that there is an event space to unbind            if (callbackSpace) {                // Only unbind if there's an event bound with eventName and a callback with the specified callback                if (callbackSpace[callback]) {                    $(that).unbind(makeEventName(eventName), callbackSpace[callback]);                    // Remove the callback from the callback map                    delete callbackSpace[callback];                    // Check if there are any members left on the event, if not we need to destroy it.                    if (!hasMembers(callbackSpace)) {                        delete callbackMap[eventName];                    }                } else if (!callback) { // Check if we're removing the whole event and we didn't error because of an invalid callback                    $(that).unbind(makeEventName(eventName));                    delete callbackMap[eventName];                }            }            return that;        },        invoke: function (methodName) {            /// <summary>Invokes a server hub method with the given arguments.</summary>            /// <param name="methodName" type="String">The name of the server hub method.</param>            var that = this,                connection = that.connection,                args = $.makeArray(arguments).slice(1),                argValues = map(args, getArgValue),                data = { H: that.hubName, M: methodName, A: argValues, I: connection._.invocationCallbackId },                d = $.Deferred(),                callback = function (minResult) {                    var result = that._maximizeHubResponse(minResult),                        source,                        error;                    // Update the hub state                    $.extend(that.state, result.State);                    if (result.Error) {                        // Server hub method threw an exception, log it & reject the deferred                        if (result.StackTrace) {                            connection.log(result.Error + "\n" + result.StackTrace + ".");                        }                        // result.ErrorData is only set if a HubException was thrown                        source = result.IsHubException ? "HubException" : "Exception";                        error = signalR._.error(result.Error, source);                        error.data = result.ErrorData;                        connection.log(that.hubName + "." + methodName + " failed to execute. Error: " + error.message);                        d.rejectWith(that, [error]);                    } else {                        // Server invocation succeeded, resolve the deferred                        connection.log("Invoked " + that.hubName + "." + methodName);                        d.resolveWith(that, [result.Result]);                    }                };            connection._.invocationCallbacks[connection._.invocationCallbackId.toString()] = { scope: that, method: callback };            connection._.invocationCallbackId += 1;            if (!$.isEmptyObject(that.state)) {                data.S = that.state;            }            connection.log("Invoking " + that.hubName + "." + methodName);            connection.send(data);            return d.promise();        },        _maximizeHubResponse: function (minHubResponse) {            return {                State: minHubResponse.S,                Result: minHubResponse.R,                Id: minHubResponse.I,                IsHubException: minHubResponse.H,                Error: minHubResponse.E,                StackTrace: minHubResponse.T,                ErrorData: minHubResponse.D            };        }    };    hubProxy.fn.init.prototype = hubProxy.fn;    // hubConnection    function hubConnection(url, options) {        /// <summary>Creates a new hub connection.</summary>        /// <param name="url" type="String">[Optional] The hub route url, defaults to "/signalr".</param>        /// <param name="options" type="Object">[Optional] Settings to use when creating the hubConnection.</param>        var settings = {            qs: null,            logging: false,            useDefaultPath: true        };        $.extend(settings, options);        if (!url || settings.useDefaultPath) {            url = (url || "") + "/signalr";        }        return new hubConnection.fn.init(url, settings);    }    hubConnection.fn = hubConnection.prototype = $.connection();    hubConnection.fn.init = function (url, options) {        var settings = {                qs: null,                logging: false,                useDefaultPath: true            },            connection = this;        $.extend(settings, options);        // Call the base constructor        $.signalR.fn.init.call(connection, url, settings.qs, settings.logging);        // Object to store hub proxies for this connection        connection.proxies = {};        connection._.invocationCallbackId = 0;        connection._.invocationCallbacks = {};        // Wire up the received handler        connection.received(function (minData) {            var data, proxy, dataCallbackId, callback, hubName, eventName;            if (!minData) {                return;            }            if (typeof (minData.I) !== "undefined") {                // We received the return value from a server method invocation, look up callback by id and call it                dataCallbackId = minData.I.toString();                callback = connection._.invocationCallbacks[dataCallbackId];                if (callback) {                    // Delete the callback from the proxy                    connection._.invocationCallbacks[dataCallbackId] = null;                    delete connection._.invocationCallbacks[dataCallbackId];                    // Invoke the callback                    callback.method.call(callback.scope, minData);                }            } else {                data = this._maximizeClientHubInvocation(minData);                // We received a client invocation request, i.e. broadcast from server hub                connection.log("Triggering client hub event '" + data.Method + "' on hub '" + data.Hub + "'.");                // Normalize the names to lowercase                hubName = data.Hub.toLowerCase();                eventName = data.Method.toLowerCase();                // Trigger the local invocation event                proxy = this.proxies[hubName];                // Update the hub state                $.extend(proxy.state, data.State);                $(proxy).triggerHandler(makeEventName(eventName), [data.Args]);            }        });        connection.error(function (errData, origData) {            var callbackId, callback;            if (!origData) {                // No original data passed so this is not a send error                return;            }            callbackId = origData.I;            callback = connection._.invocationCallbacks[callbackId];            // Verify that there is a callback bound (could have been cleared)            if (callback) {                // Delete the callback                connection._.invocationCallbacks[callbackId] = null;                delete connection._.invocationCallbacks[callbackId];                // Invoke the callback with an error to reject the promise                callback.method.call(callback.scope, { E: errData });            }        });        connection.reconnecting(function () {            if (connection.transport && connection.transport.name === "webSockets") {                clearInvocationCallbacks(connection, "Connection started reconnecting before invocation result was received.");            }        });        connection.disconnected(function () {            clearInvocationCallbacks(connection, "Connection was disconnected before invocation result was received.");        });    };    hubConnection.fn._maximizeClientHubInvocation = function (minClientHubInvocation) {        return {            Hub: minClientHubInvocation.H,            Method: minClientHubInvocation.M,            Args: minClientHubInvocation.A,            State: minClientHubInvocation.S        };    };    hubConnection.fn._registerSubscribedHubs = function () {        /// <summary>        ///     Sets the starting event to loop through the known hubs and register any new hubs        ///     that have been added to the proxy.        /// </summary>        var connection = this;        if (!connection._subscribedToHubs) {            connection._subscribedToHubs = true;            connection.starting(function () {                // Set the connection's data object with all the hub proxies with active subscriptions.                // These proxies will receive notifications from the server.                var subscribedHubs = [];                $.each(connection.proxies, function (key) {                    if (this.hasSubscriptions()) {                        subscribedHubs.push({ name: key });                        connection.log("Client subscribed to hub '" + key + "'.");                    }                });                if (subscribedHubs.length === 0) {                    connection.log("No hubs have been subscribed to.  The client will not receive data from hubs.  To fix, declare at least one client side function prior to connection start for each hub you wish to subscribe to.");                }                connection.data = connection.json.stringify(subscribedHubs);            });        }    };    hubConnection.fn.createHubProxy = function (hubName) {        /// <summary>        ///     Creates a new proxy object for the given hub connection that can be used to invoke        ///     methods on server hubs and handle client method invocation requests from the server.        /// </summary>        /// <param name="hubName" type="String">        ///     The name of the hub on the server to create the proxy for.        /// </param>        // Normalize the name to lowercase        hubName = hubName.toLowerCase();        var proxy = this.proxies[hubName];        if (!proxy) {            proxy = hubProxy(this, hubName);            this.proxies[hubName] = proxy;        }        this._registerSubscribedHubs();        return proxy;    };    hubConnection.fn.init.prototype = hubConnection.fn;    $.hubConnection = hubConnection;}(window.jQuery, window));/* jquery.signalR.version.js */// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.md in the project root for license information./*global window:false *//// <reference path="jquery.signalR.core.js" />(function ($, undefined) {    $.signalR.version = "2.0.3";}(window.jQuery));
libs/moment.js:1222:            // TODO: We need to take the current isoWeekYear, but that depends on
libs/moment.js:2343:        // TODO: Move this out of here!
libs/moment.js:2346:            // TODO: Another silent failure?
libs/ui-router.js:854:    // TODO: Maybe we should throw on null here? It's not really good style to use '' and null interchangeabley
libs/ui-router.js:1144:      // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree
libs/ui-router.js:1999:      // TODO: We may not want to bump 'transition' if we're called from a location change that we've initiated ourselves,
libs/vis.js:444:  // TODO: add support for Arrays to deepExtend
libs/vis.js:1339:// TODO: add a DataSet constructor DataSet(data, options)
libs/vis.js:1368:  // TODO: deprecated since version 1.1.1 (or 2.0.0?)
libs/vis.js:1402:// TODO: make this function deprecated (replaced with `on` since version 0.5)
libs/vis.js:1419:// TODO: make this function deprecated (replaced with `on` since version 0.5)
libs/vis.js:1930:  // TODO: extend order by an Object {field:String, direction:String}
libs/vis.js:2254:// TODO: implement a function .config() to dynamically update things like configured filter
libs/vis.js:2509:// TODO: make these functions deprecated (replaced with `on` and `off` since version 0.5)
libs/vis.js:2571:        // TODO: optimize checking for overlap. when there is a gap without items,
libs/vis.js:3604:  // TODO: reckon with min and max range
libs/vis.js:3712:    // TODO: implement timeaxis orientations 'left' and 'right'
libs/vis.js:3786:  // TODO: recalculate sizes only needed when parent is resized or options is changed
libs/vis.js:3799:  props.minorLineWidth = 1; // TODO: really calculate width
libs/vis.js:3801:  props.majorLineWidth = 1; // TODO: really calculate width
libs/vis.js:3867:    // TODO: lines must have a width, such that we can create css backgrounds
libs/vis.js:3936:  //label.title = title;  // TODO: this is a heavy operation
libs/vis.js:3961:  //label.title = title; // TODO: this is a heavy operation
libs/vis.js:4805:  // TODO: would be nicer to get this as a trigger from Range
libs/vis.js:5079:        item.id = id; // TODO: not so nice setting id afterwards
libs/vis.js:5130:  // TODO: optimization: only reorder groups affected by the changed items
libs/vis.js:5451:    // TODO: implement onMoving handler
libs/vis.js:5607:        // TODO: need to trigger a redraw?
libs/vis.js:5720: *                                  // TODO: describe available options
libs/vis.js:5861: *                                  // TODO: describe available options
libs/vis.js:5894:  // TODO: account for the real width of the item. Right now we just add 1/4 to the window
libs/vis.js:6073:    var itemSetHeight = this.parent.itemSet.props.height; // TODO: this is nasty
libs/vis.js:6092: *                                  // TODO: describe available options
libs/vis.js:6126:  // TODO: account for the real width of the item. Right now we just add 1/4 to the window
libs/vis.js:6209:    //dom.content.style.marginRight = ... + 'px'; // TODO: margin right
libs/vis.js:6283: *                                  // TODO: describe options
libs/vis.js:6448:    // TODO: remove the need for options.padding. it's terrible.
libs/vis.js:6489:    // TODO: this should be redundant?
libs/vis.js:6519:    // TODO: this should be redundant?
libs/vis.js:6546: *                                  // TODO: describe options
libs/vis.js:6738:  if (this.itemSet.options.stack) { // TODO: ugly way to access options...
libs/vis.js:6841:    var range = this.itemSet.body.range; // TODO: not nice accessing the range like this
libs/vis.js:6858:  // TODO: also remove from ordered items?
libs/vis.js:7350:  // TODO: remove deprecation error one day (deprecated since version 0.8.0)
libs/vis.js:7634:  // TODO: compensate borders when any of the panels is empty.
libs/vis.js:7637:  // TODO: only calculate autoHeight when needed (else we cause an extra reflow/repaint of the DOM)
libs/vis.js:7734:// TODO: deprecated since version 1.1.0, remove some day
libs/vis.js:7745:// TODO: move this function to Range
libs/vis.js:7758:// TODO: move this function to Range
libs/vis.js:7870:    this.redraw(); // TODO: this causes two redraws when dragging, the other is triggered by rangechange already
libs/vis.js:8238:    // TODO: more precise parsing of numbers/strings (and the port separator ':')
libs/vis.js:8394:      // TODO: implement comma separated list with "a_list: ID=ID [','] [a_list] "
libs/vis.js:8924:    // TODO: allow to customize different shapes
libs/vis.js:8972:  // TODO: add diamond shape
libs/vis.js:9185:    // TODO: add diamond shape
libs/vis.js:9266:    // TODO: implement distanceToBorder for database
libs/vis.js:9267:    // TODO: implement distanceToBorder for triangle
libs/vis.js:9268:    // TODO: implement distanceToBorder for triangleDown
libs/vis.js:9278:        // TODO: reckon with border radius too in case of box
libs/vis.js:9285:  // TODO: implement calculation of distance to border for all shapes
libs/vis.js:9373:// TODO: replace this method with calculating the kinetic energy
libs/vis.js:9457:  // TODO: pre calculate the image size
libs/vis.js:10309:    // TODO: cache the calculated size
libs/vis.js:10636:    // TODO: similarly, for a line without arrows, draw to the border of the nodes instead of the center
libs/vis.js:16678:    // TODO: work out these options and document them
libs/vis.js:17097:  // TODO: enabled moving while pinching?
libs/vis.js:18343:  this.showGrayBottom = false; // TODO: this does not work correctly
libs/vis.js:18351:  this.eye = new Point3d(0, 0, -1);  // TODO: set eye.z about 3/4 of the width of the window?
libs/vis.js:18376:  // TODO: customize axis range
libs/vis.js:18553:  // TODO: can this be automated? verticalRatio?
libs/vis.js:18925:  // TODO: store the created matrix dataPoints in the filters instead of reloading each time
libs/vis.js:18963:      var xIndex = dataX.indexOf(x);  // TODO: implement Array().indexOf() for Internet Explorer
libs/vis.js:19081:  // TODO: these events are never cleaned up... can give a 'memory leakage'
libs/vis.js:19410:  ctx.font = '14px arial'; // TODO: put in options
libs/vis.js:19493:    // TODO: css here is not nice here...
libs/vis.js:19535:    ctx.font = '14px arial'; // TODO: put in options
libs/vis.js:19559:  // TODO: get the actual rendered style of the containerElement
libs/vis.js:19696:    // TODO: make z-grid lines really 3d?
libs/vis.js:19807:    offset = 30;  // pixels.  // TODO: relate to the max width of the values on the z axis?
libs/vis.js:19861:    return; // TODO: throw exception?
libs/vis.js:19915:            v = Math.min(1 + (crossproduct.x / len) / 2, 1);  // value. TODO: scale
libs/vis.js:20000:    return;  // TODO: throw exception?
libs/vis.js:20096:    return;  // TODO: throw exception?
libs/vis.js:20186:      // TODO: this dept calculation doesn't work 100% of the cases due to perspective,
libs/vis.js:20235:    return;  // TODO: throw exception?
libs/vis.js:20250:    ctx.lineWidth = 1;    // TODO: make customizable
libs/vis.js:20251:    ctx.strokeStyle = 'blue'; // TODO: make customizable
libs/vis.js:21042:    //this.graph.redrawInfo(); // TODO: not neat
libs/vis.js:21053:    // TODO: this is no nice solution...
libs/vis.js:21054:    frame.progress.style.bottom = Graph3d.px(60); // TODO: use height of slider
libs/vis.js:21338:  // document.title = diff // TODO: cleanup
libs/vis.js:24496:            // TODO: We need to take the current isoWeekYear, but that depends on
libs/vis.js:25617:        // TODO: Move this out of here!
libs/vis.js:25620:            // TODO: Another silent failure?
libs/vis.js:26643:       * TODO: actually remove this from the _callbacks dictionary instead
libs/x_jquery-ui.js:294:		// TODO: determine which cases actually cause this to happen
libs/x_jquery-ui.js:423:				// TODO: add this back in 1.9 and use $.error() (see #5972)
libs/x_jquery-ui.js:626:	// TODO: make sure destroying one instance of mouse doesn't mess with
libs/x_jquery-ui.js:1971:				//TODO : this modifies original option
libs/x_jquery-ui.js:1974:				//TODO : What's going on here?
libs/x_jquery-ui.js:2015:				//TODO: What's that good for? There's not anything to be executed left
libs/x_jquery-ui.js:2022:		//TODO: make renderAxis a prototype function
libs/x_jquery-ui.js:2071:		//TODO: Unwrap at same DOM position
libs/x_jquery-ui.js:2194:				soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : self.sizeDiff.height,
libs/x_jquery-ui.js:2343:			// fix ie6 offset TODO: This seems broken
libs/x_jquery-ui.js:2353:				zIndex: ++o.zIndex //TODO: Don't modify option
libs/x_jquery-ui.js:2514:					soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : self.sizeDiff.height,
libs/x_jquery-ui.js:3128:		// TODO: Still need to figure out a way to make relative sorting possible
libs/x_jquery-ui.js:3659:		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
libs/x_jquery-ui.js:4531:			// TODO: make effects take actual parameters instead of a hash
libs/x_jquery-ui.js:5929:		// TODO this gets called on init, changing the option without an explicit call for that
libs/x_jquery-ui.js:5948:	// TODO isn't event.target enough? why the separate target argument?
libs/x_jquery-ui.js:5984:		// TODO the option is changed, is that correct?
libs/x_jquery-ui.js:5985:		// TODO if it is correct, shouldn't that happen after determining that the click is valid?
libs/x_jquery-ui.js:6121:		// TODO assert that the blur and focus triggers are really necessary, remove otherwise
libs/x_jquery-ui.js:6297:			// TODO verify these actually work as intended
libs/x_jquery-ui.js:6612:		// TODO refresh should check if the active item is still in the dom, removing the need for a manual deactivate
libs/x_jquery-ui.js:6801:	// TODO merge with previousPage
libs/x_jquery-ui.js:6804:			// TODO merge with no-scroll-else
libs/x_jquery-ui.js:6813:					// TODO improve approximation
libs/x_jquery-ui.js:6817:			// TODO try to catch this earlier when scrollTop indicates the last page anyway
libs/x_jquery-ui.js:6828:	// TODO merge with nextPage
libs/x_jquery-ui.js:6831:			// TODO merge with no-scroll-else
libs/x_jquery-ui.js:6841:					// TODO improve approximation
libs/x_jquery-ui.js:6845:			// TODO try to catch this earlier when scrollTop indicates the last page anyway
libs/x_jquery-ui.js:7065:						// TODO pass through original event correctly (just as 2nd argument doesn't work)
libs/x_jquery-ui.js:7072:		// TODO: pull out $.Widget's handling for the disabled option into
libs/x_jquery-ui.js:7409:	// TODO rename to "widget" when switching to widget factory
libs/x_jquery-ui.js:9291:		//TODO: remove in 1.9pre
libs/x_jquery-ui.js:9692:			//TODO: remove in 1.9pre
libs/x_jquery-ui.js:10022:	// TODO: use $.isWindow() in 1.9
libs/x_jquery-ui.js:11145:				// TODO until #3808 is fixed strip fragment identifier from url
libs/x_jquery-ui.js:11195:			} else if ( o.selected === null ) { // usage of null is deprecated, TODO remove in next release
libs/x_jquery-ui.js:11235:			// TODO: namespace this event
libs/x_jquery-ui.js:11246:		// TODO: use .toggleClass()
libs/x_jquery-ui.js:11257:				// TODO: use .toggleClass()
libs/x_jquery-ui.js:11392:					// TODO make passing in node possible, see also http://dev.jqueryui.com/ticket/3171
libs/xeditable.js:269:TODO: this file should be refactored to work more clear without closures!
libs/xfullcalendar.js:499:	t.getDefaultEventEnd = function(allDay, start) { // TODO: rename to computeDefaultEventEnd
libs/xfullcalendar.js:525:		// a function that returns a formatStr // TODO: in future, precompute this
libs/xfullcalendar.js:537:		// a function that returns a formatStr // TODO: in future, precompute this
libs/xfullcalendar.js:837:	// TODO: going forward, most of this stuff should be directly handled by the view
libs/xfullcalendar.js:852:	function renderEvents(modifiedEventID) { // TODO: remove modifiedEventID hack
libs/xfullcalendar.js:863:		currentView.clearEventData(); // for View.js, TODO: unify with clearEvents
libs/xfullcalendar.js:1049:		// TODO: unbind on destroy
libs/xfullcalendar.js:1507:				// TODO: repeat code, same code for event classNames
libs/xfullcalendar.js:2112://TODO: arraySlice
libs/xfullcalendar.js:2113://TODO: isFunction, grep ?
libs/xfullcalendar.js:2179:function markFirstLast(e) { // TODO: use CSS selectors instead
libs/xfullcalendar.js:2430:	this.year(a[0]) // TODO: find a way to do this in one shot
libs/xfullcalendar.js:2464:	this.year(a[0]) // TODO: find a way to do this in one shot
libs/xfullcalendar.js:2516:		this.year(a[0]) // TODO: find a way to do this in one shot
libs/xfullcalendar.js:2685:// TODO: make it work with timezone offset
libs/xfullcalendar.js:2779:// TODO: week maybe?
libs/xfullcalendar.js:2823:	var chunker = /\[([^\]]*)\]|\(([^\)]*)\)|(LT|(\w)\4*o?)|([^\w\[\(]+)/g; // TODO: more descrimination
libs/xfullcalendar.js:2901:function BasicWeekView(element, calendar) { // TODO: do a WeekView mixin
libs/xfullcalendar.js:2944:function BasicDayView(element, calendar) { // TODO: make a DayView mixin
libs/xfullcalendar.js:3334:	// TODO: should be consolidated with AgendaView's methods
libs/xfullcalendar.js:3518:	// TODO: have this class (and AgendaEventRenderer) be responsible for creating the event container div
libs/xfullcalendar.js:3526:function AgendaWeekView(element, calendar) { // TODO: do a WeekView mixin
libs/xfullcalendar.js:3569:function AgendaDayView(element, calendar) { // TODO: make a DayView mixin
libs/xfullcalendar.js:3640:// TODO: make it work in quirks mode (event corners, all-day height)
libs/xfullcalendar.js:3641:// TODO: test liquid width, especially in IE6
libs/xfullcalendar.js:3731:	var slotHeight; // TODO: what if slotHeight changes? (see issue 650)
libs/xfullcalendar.js:3919:		// TODO: now that we rebuild the cells every time, we should call dayRender
libs/xfullcalendar.js:3981:		var headerClass = tm + "-widget-header"; // TODO: make these when updateOptions() called
libs/xfullcalendar.js:4042:	// TODO: data-date on the cells
libs/xfullcalendar.js:4175:			var match = this.parentNode.className.match(/fc-slot(\d+)/); // TODO: maybe use data
libs/xfullcalendar.js:4201:	// TODO: should be consolidated with BasicView's methods
libs/xfullcalendar.js:4332:	function getIsCellAllDay(cell) { // TODO: remove because mom.hasTime() from realCellToDate() is better
libs/xfullcalendar.js:4733:	// TODO: when we refactor this, when user returns `false` eventRender, don't have empty space
libs/xfullcalendar.js:4734:	// TODO: refactor will include using pixels to detect collisions instead of dates (handy for seg cmp)
libs/xfullcalendar.js:4768:			// TODO: move this to CSS somehow
libs/xfullcalendar.js:4861:					// not enough room for title, put it in the time (TODO: maybe make both display:inline instead)
libs/xfullcalendar.js:5538:	var eventElementCouples = []; // array of objects, { event, element } // TODO: unify with segment system
libs/xfullcalendar.js:5647:		// TODO: don't fire eventMouseover/eventMouseout *while* dragging is occuring (on subject element)
libs/xfullcalendar.js:5648:		// TODO: same for resizing
libs/xfullcalendar.js:6043:	var allDayRow = t.allDayRow; // TODO: rename
libs/xfullcalendar.js:6308:		// TODO:
libs/xfullcalendar.js:6545:	// TODO: better documentation!
libs/xfullcalendar.js:6638:		var handle = element.find('.ui-resizable-' + direction); // TODO: stop using this class because we aren't using jqui for this
libs/xfullcalendar.js:6641:		// TODO: look into using jquery-ui mouse widget for this stuff
libs/xfullcalendar.js:6710:						// TODO: instead of calling renderDayOverlay() with dates,
libs/xfullcalendar.js:6764:function segmentElementEach(segments, callback) { // TODO: use in AgendaView?
libs/xfullcalendar.js:6845:	// TODO: better date normalization. see notes in automated test
libs/xfullcalendar.js:6872:			hoverListener.start(function(cell, origCell) { // TODO: maybe put cellToDate/getIsCellAllDay info in cell
node_modules/.bin/r.js:7544:            // TODO(ikarienator): Should we update the test cases instead?
node_modules/.bin/r.js:8390:// TODO(user) Consolidation of mathematical values found in numeric literals.
node_modules/.bin/r.js:8391:// TODO(user) Unconsolidation.
node_modules/.bin/r.js:8392:// TODO(user) Consolidation of ECMA-262 6th Edition programs.
node_modules/.bin/r.js:8393:// TODO(user) Rewrite in ECMA-262 6th Edition.
node_modules/.bin/r.js:26711:                    // TODO: need to generalize this work, maybe also reuse
node_modules/assert/node_modules/gulp-traceur/node_modules/gulp-util/lib/PluginError.js:53:  // TODO: figure out why this explodes mocha
node_modules/assert/node_modules/gulp-traceur/node_modules/gulp-util/node_modules/event-stream/node_modules/split/index.js:13://TODO pass in a function to map across the lines.
node_modules/assert/node_modules/gulp-traceur/node_modules/gulp-util/node_modules/vinyl/index.js:14:  // TODO: should this be moved to vinyl-fs?
node_modules/assert/node_modules/gulp-traceur/node_modules/gulp-util/node_modules/vinyl/index.js:21:  // TODO: should this be moved to vinyl-fs?
node_modules/assert/node_modules/gulp-traceur/node_modules/gulp-util/node_modules/vinyl/index.js:40:// TODO: should this be moved to vinyl-fs?
node_modules/assert/node_modules/gulp-traceur/node_modules/gulp-util/node_modules/vinyl/index.js:116:// TODO: should this be moved to vinyl-fs?
node_modules/assert/node_modules/gulp-traceur/node_modules/through2/node_modules/readable-stream/lib/_stream_writable.js:146:  // TODO: defer error events consistently everywhere, not just the cb
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/fs-boot.js:4:// -- tlrobinson Tom Robinson TODO
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/fs-common.js:6:// TODO patternToRegExp
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/fs-common.js:7:// TODO glob
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/fs-common.js:8:// TODO match
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/fs-common.js:180:                // TODO copy the link and type with readPath (but what about
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/http-apps/fs.js:56:                //TODO remove for 2.0.0
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/http-apps/fs.js:65:                // TODO: relativeFromFile should be designed for URLs, not generalized paths.
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/http-apps/fs.js:85:    // TODO last-modified header
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/http-apps/fs.js:135:            // TODO consider if-match?
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/http-apps/fs.js:141:        // TODO sendfile
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/http-apps/fs.js:189:            return; // Can't satisfy non-contiguous ranges TODO
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/http-apps/fs.js:237:    // TODO advisory to have JSON or HTML fragment handler.
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/http-apps/fs.js:388:        // TODO worry about whether this file actually exists
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/http-apps/html.js:3:// TODO negotiate text/html vs text/html+fragment (or other mime type)
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/http-apps/route.js:20:        // TODO Distinguish these cases
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/http.js:296:                // TODO find a better way to channel
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/node_modules/collections/heap.js:214:    // TODO refactor dispatchers to allow direct forwarding
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/node_modules/collections/list.js:352:// TODO account for missing basis argument
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/node_modules/collections/listen/map-changes.js:70:            // TODO throw new Error("Can't remove map change listener again");
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/node_modules/collections/listen/property-changes.js:267:    // TODO reflect current value on a displayed property
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/node_modules/collections/listen/range-changes.js:60:            // TODO throw new Error("Range change listener " + JSON.stringify(token) + " has already been canceled");
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/node_modules/collections/node_modules/weak-map/weak-map.js:55: * rather than the offially approved proposal page. TODO(erights):
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/node_modules/collections/node_modules/weak-map/weak-map.js:182:   * <p>TODO(erights): On a platform with built-in Proxies, proxies
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/node_modules/collections/node_modules/weak-map/weak-map.js:188:   * <p>TODO(erights): Revisit Mike Stay's suggestion that we use an
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/node_modules/collections/shim-function.js:53:// TODO document
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/node_modules/collections/shim-object.js:292:// TODO inline document concat
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/node_modules/collections/sorted-set.js:551:// TODO case where no basis is provided for reduction
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/node_modules/q/q.js:689:            // TODO: "===" should be Object.is or equiv
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/node_modules/q/q.js:1658:        // TODO attempt to recycle the rejection with "this".
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/reader.js:17:    if (charset && _stream.setEncoding) // TODO complain about inconsistency
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/spec/http-apps/partial-range-spec.js:60:            // TODO
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/spec/http-apps/partial-range-spec.js:103:                // TODO
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/spec/http-apps/partial-range-spec.js:176:            // TODO
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/node_modules/q-io/writer.js:21:    if (charset && _stream.setEncoding) // TODO complain about inconsistency
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/src/node/api.js:54: * TODO(vojta): Support source maps.
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/src/node/command.js:127:      // TODO: Is this needed at all for traceur?
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/src/node/command.js:185:  // TODO: Start trepl
node_modules/assert/node_modules/gulp-traceur/node_modules/traceur/src/node/deferred.js:103:  // TODO: find and wrap everything that needs to be wrapped.
node_modules/assert/src/assert.js:1:// TODO(vojta):
node_modules/assert/src/assert.js:34:      // TODO(vojta): print "an instance of" only if T starts with uppercase.
node_modules/assert/src/assert.js:157:    // TODO(vojta): print "an instance of" only if T starts with uppercase.
node_modules/assert/src/assert.js:173:    // TODO(vojta): print "an instance of" only if T starts with uppercase.
node_modules/assert/src/assert.js:186:// TODO(vojta): define these with DSL?
node_modules/gulp/node_modules/gulp-util/lib/PluginError.js:49:  // TODO: figure out why this explodes mocha
node_modules/gulp/node_modules/gulp-util/node_modules/multipipe/node_modules/duplexer2/node_modules/readable-stream/lib/_stream_writable.js:157:  // TODO: defer error events consistently everywhere, not just the cb
node_modules/gulp/node_modules/gulp-util/node_modules/multipipe/node_modules/duplexer2/node_modules/readable-stream/lib/_stream_writable.js:360:    // TODO(isaacs) clean this up
node_modules/gulp/node_modules/gulp-util/node_modules/through2/node_modules/readable-stream/lib/_stream_writable.js:146:  // TODO: defer error events consistently everywhere, not just the cb
node_modules/gulp/node_modules/gulp-util/node_modules/vinyl/index.js:14:  // TODO: should this be moved to vinyl-fs?
node_modules/gulp/node_modules/gulp-util/node_modules/vinyl/index.js:21:  // TODO: should this be moved to vinyl-fs?
node_modules/gulp/node_modules/gulp-util/node_modules/vinyl/index.js:40:// TODO: should this be moved to vinyl-fs?
node_modules/gulp/node_modules/gulp-util/node_modules/vinyl/index.js:116:// TODO: should this be moved to vinyl-fs?
node_modules/gulp/node_modules/liftoff/index.js:44:// TODO: break this into smaller methods.
node_modules/gulp/node_modules/liftoff/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/test/basic.js:3:// TODO: Some of these tests do very bad things with backslashes, and will
node_modules/gulp/node_modules/liftoff/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/test/defaults.js:3:// TODO: Some of these tests do very bad things with backslashes, and will
node_modules/gulp/node_modules/vinyl-fs/lib/dest/writeStream.js:13:  // TODO: can we pass the file along before the stream is unloaded?
node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-stream/index.js:87:    // TODO: set up streaming queue so items come in order
node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-stream/node_modules/minimatch/test/basic.js:3:// TODO: Some of these tests do very bad things with backslashes, and will
node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-stream/node_modules/minimatch/test/defaults.js:3:// TODO: Some of these tests do very bad things with backslashes, and will
node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-stream/node_modules/through2/node_modules/readable-stream/lib/_stream_writable.js:146:  // TODO: defer error events consistently everywhere, not just the cb
node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-watcher/node_modules/gaze/node_modules/globule/node_modules/minimatch/test/basic.js:3:// TODO: Some of these tests do very bad things with backslashes, and will
node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-watcher/node_modules/gaze/node_modules/globule/node_modules/minimatch/test/defaults.js:3:// TODO: Some of these tests do very bad things with backslashes, and will
node_modules/gulp/node_modules/vinyl-fs/node_modules/vinyl/index.js:14:  // TODO: should this be moved to vinyl-fs?
node_modules/gulp/node_modules/vinyl-fs/node_modules/vinyl/index.js:21:  // TODO: should this be moved to vinyl-fs?
node_modules/gulp/node_modules/vinyl-fs/node_modules/vinyl/index.js:40:// TODO: should this be moved to vinyl-fs?
node_modules/gulp/node_modules/vinyl-fs/node_modules/vinyl/index.js:116:// TODO: should this be moved to vinyl-fs?
node_modules/gulp-concat/node_modules/concat-with-sourcemaps/node_modules/source-map/test/source-map/test-util.js:202:  // TODO Issue #128: Define and test this function properly.
node_modules/gulp-concat/node_modules/gulp-util/lib/PluginError.js:49:  // TODO: figure out why this explodes mocha
node_modules/gulp-concat/node_modules/gulp-util/node_modules/multipipe/node_modules/duplexer2/node_modules/readable-stream/lib/_stream_writable.js:157:  // TODO: defer error events consistently everywhere, not just the cb
node_modules/gulp-concat/node_modules/gulp-util/node_modules/multipipe/node_modules/duplexer2/node_modules/readable-stream/lib/_stream_writable.js:360:    // TODO(isaacs) clean this up
node_modules/gulp-concat/node_modules/gulp-util/node_modules/through2/node_modules/readable-stream/lib/_stream_writable.js:146:  // TODO: defer error events consistently everywhere, not just the cb
node_modules/gulp-concat/node_modules/gulp-util/node_modules/vinyl/index.js:14:  // TODO: should this be moved to vinyl-fs?
node_modules/gulp-concat/node_modules/gulp-util/node_modules/vinyl/index.js:21:  // TODO: should this be moved to vinyl-fs?
node_modules/gulp-concat/node_modules/gulp-util/node_modules/vinyl/index.js:40:// TODO: should this be moved to vinyl-fs?
node_modules/gulp-concat/node_modules/gulp-util/node_modules/vinyl/index.js:116:// TODO: should this be moved to vinyl-fs?
node_modules/gulp-connect/node_modules/connect/lib/middleware/cookieSession.js:51:  // TODO: utilize Session/Cookie to unify API
node_modules/gulp-connect/node_modules/connect/lib/middleware/cookieSession.js:75:      // TODO: refactor
node_modules/gulp-connect/node_modules/connect/lib/middleware/staticCache.js:73:    // TODO: change from staticCache() -> cache()
node_modules/gulp-connect/node_modules/connect/lib/middleware/staticCache.js:94:      // TODO: real support for must-revalidate / no-cache
node_modules/gulp-connect/node_modules/connect/lib/middleware/staticCache.js:124:        delete headers['x-cache']; // Clean up (TODO: others)
node_modules/gulp-connect/node_modules/connect/lib/middleware/staticCache.js:149: * TODO: Assume 200 code, that's iffy.
node_modules/gulp-connect/node_modules/connect/node_modules/cookie-parser/test/cookieParser.js:44:    // TODO: "bar" fails...
node_modules/gulp-connect/node_modules/connect/node_modules/multiparty/node_modules/readable-stream/lib/_stream_writable.js:157:  // TODO: defer error events consistently everywhere, not just the cb
node_modules/gulp-connect/node_modules/connect/node_modules/multiparty/node_modules/readable-stream/lib/_stream_writable.js:360:    // TODO(isaacs) clean this up
node_modules/gulp-connect/node_modules/connect/node_modules/serve-index/index.js:10:// TODO: arrow key navigation
node_modules/gulp-connect/node_modules/connect/node_modules/serve-index/index.js:11:// TODO: make icons extensible
node_modules/gulp-connect/node_modules/connect/node_modules/serve-static/node_modules/send/lib/send.js:513:  // TODO: this is all lame, refactor meeee
node_modules/gulp-connect/node_modules/connect/node_modules/setimmediate/qUnitTest/lib/qunit.js:79:		// TODO why??
node_modules/gulp-connect/node_modules/event-stream/node_modules/split/index.js:13://TODO pass in a function to map across the lines.
node_modules/gulp-connect/node_modules/gulp-util/lib/PluginError.js:49:  // TODO: figure out why this explodes mocha
node_modules/gulp-connect/node_modules/gulp-util/node_modules/multipipe/node_modules/duplexer2/node_modules/readable-stream/lib/_stream_writable.js:157:  // TODO: defer error events consistently everywhere, not just the cb
node_modules/gulp-connect/node_modules/gulp-util/node_modules/multipipe/node_modules/duplexer2/node_modules/readable-stream/lib/_stream_writable.js:360:    // TODO(isaacs) clean this up
node_modules/gulp-connect/node_modules/gulp-util/node_modules/through2/node_modules/readable-stream/lib/_stream_writable.js:146:  // TODO: defer error events consistently everywhere, not just the cb
node_modules/gulp-connect/node_modules/gulp-util/node_modules/vinyl/index.js:14:  // TODO: should this be moved to vinyl-fs?
node_modules/gulp-connect/node_modules/gulp-util/node_modules/vinyl/index.js:21:  // TODO: should this be moved to vinyl-fs?
node_modules/gulp-connect/node_modules/gulp-util/node_modules/vinyl/index.js:40:// TODO: should this be moved to vinyl-fs?
node_modules/gulp-connect/node_modules/gulp-util/node_modules/vinyl/index.js:116:// TODO: should this be moved to vinyl-fs?
node_modules/gulp-connect/node_modules/tiny-lr/node_modules/qs/test/browser/jquery.js:1472:			// TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
node_modules/gulp-connect/node_modules/tiny-lr/node_modules/qs/test/browser/jquery.js:1507:		// TODO: This is a hack for 1.5 ONLY. It will be removed in 1.6. Users should
node_modules/gulp-connect/node_modules/tiny-lr/node_modules/qs/test/browser/jquery.js:1580:			// TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
node_modules/gulp-connect/node_modules/tiny-lr/node_modules/qs/test/browser/jquery.js:1718:// TODO: This is a hack for 1.5 ONLY to allow objects with a single toJSON
node_modules/gulp-connect/node_modules/tiny-lr/node_modules/qs/test/browser/jquery.js:2856:			// TODO: Stop taunting the data cache; remove global events and always attach to document
node_modules/gulp-connect/node_modules/tiny-lr/node_modules/qs/test/browser/jquery.js:4263:			// TODO: Move to normal caching system
node_modules/gulp-connect/node_modules/tiny-lr/node_modules/qs/test/browser/mocha.js:1693:    // TODO: add to stats
node_modules/gulp-connect/node_modules/tiny-lr/node_modules/qs/test/browser/mocha.js:1739:    // TODO: defer
node_modules/gulp-esnext/node_modules/esnext/node_modules/ast-types/def/core.js:54:// TODO Figure out how to silently coerce Expressions to
node_modules/gulp-esnext/node_modules/esnext/node_modules/ast-types/def/core.js:179:        def("Identifier") // TODO Esprima deviation.
node_modules/gulp-esnext/node_modules/esnext/node_modules/ast-types/def/core.js:188:// TODO Are all Expressions really Patterns?
node_modules/gulp-esnext/node_modules/esnext/node_modules/ast-types/def/core.js:203:// TODO Not in the Mozilla Parser API, but used by Esprima.
node_modules/gulp-esnext/node_modules/esnext/node_modules/ast-types/def/core.js:225:    // TODO Esprima doesn't bother with this field, presumably because
node_modules/gulp-esnext/node_modules/esnext/node_modules/ast-types/def/core.js:234:    "&", // TODO Missing from the Parser API.
node_modules/gulp-esnext/node_modules/esnext/node_modules/ast-types/def/core.js:254:    // TODO Shouldn't this be def("Pattern")?
node_modules/gulp-esnext/node_modules/esnext/node_modules/ast-types/def/core.js:289:    // TODO Report this nonsense.
node_modules/gulp-esnext/node_modules/esnext/node_modules/ast-types/def/core.js:311:    // TODO File a bug to get PropertyPattern added to the interfaces API.
node_modules/gulp-esnext/node_modules/esnext/node_modules/ast-types/def/core.js:332:    // But aren't Expressions and Patterns already Nodes? TODO Report this.
node_modules/gulp-esnext/node_modules/esnext/node_modules/ast-types/def/core.js:338:    // But aren't Expressions already Nodes? TODO Report this.
node_modules/gulp-esnext/node_modules/esnext/node_modules/ast-types/def/es6.js:15:    // TODO This could be represented as a SpreadElementPattern in .params.
node_modules/gulp-esnext/node_modules/esnext/node_modules/ast-types/def/es6.js:24:// TODO The Parser API calls this ArrowExpression, but Esprima uses
node_modules/gulp-esnext/node_modules/esnext/node_modules/ast-types/def/es6.js:33:    // liberty of enforcing that. TODO Report this.
node_modules/gulp-esnext/node_modules/esnext/node_modules/ast-types/def/fb-harmony.js:68:        def("Literal") // TODO Esprima should return XJSText instead.
node_modules/gulp-esnext/node_modules/esnext/node_modules/ast-types/def/fb-harmony.js:86:    .bases("Node") // TODO Does this make sense? Can't really be an XJSElement.
node_modules/gulp-esnext/node_modules/esnext/node_modules/ast-types/def/fb-harmony.js:93:    .bases("Node") // TODO Same concern.
node_modules/gulp-esnext/node_modules/esnext/node_modules/ast-types/def/mozilla.js:19:    // TODO Deviating from the spec by reusing VariableDeclarator here.
node_modules/gulp-esnext/node_modules/esnext/node_modules/ast-types/def/mozilla.js:26:    // TODO Deviating from the spec by reusing VariableDeclarator here.
node_modules/gulp-esnext/node_modules/esnext/node_modules/ast-types/lib/types.js:470:    // like SourceLocation, but that seems harmless (TODO?).
node_modules/gulp-esnext/node_modules/esnext/node_modules/ast-types/lib/types.js:520:                // TODO Could attach getters and setters here to enforce
node_modules/gulp-esnext/node_modules/esnext/node_modules/ast-types/lib/types.js:644:        // TODO Warn if fields are overridden with incompatible types.
node_modules/gulp-esnext/node_modules/esnext/node_modules/ast-types/test/run.js:46:        // TODO Make this test case more exhaustive.
node_modules/gulp-esnext/node_modules/esnext/node_modules/es6-arrow-function/node_modules/ast-util/lib/index.js:382:  // TODO: Verify this regex.
node_modules/gulp-esnext/node_modules/esnext/node_modules/es6-class/.idea/workspace.xml:344:      <window_info id="TODO" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
node_modules/gulp-esnext/node_modules/esnext/node_modules/es6-class/node_modules/ast-util/lib/index.js:382:  // TODO: Verify this regex.
node_modules/gulp-esnext/node_modules/esnext/node_modules/es6-class/test/examples/methods-with-rest-params.js:14:    // TODO: use spread params here
node_modules/gulp-esnext/node_modules/esnext/node_modules/es6-comprehensions/node_modules/ast-util/lib/index.js:382:  // TODO: Verify this regex.
node_modules/gulp-esnext/node_modules/esnext/node_modules/es6-comprehensions/node_modules/through2/node_modules/readable-stream/lib/_stream_writable.js:146:  // TODO: defer error events consistently everywhere, not just the cb
node_modules/gulp-esnext/node_modules/esnext/node_modules/es6-spread/node_modules/ast-util/lib/index.js:382:  // TODO: Verify this regex.
node_modules/gulp-esnext/node_modules/esnext/node_modules/esprima/test/compare.js:325:    // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/recast/lib/printer.js:624:        // TODO Get the for (;;) case right.
node_modules/gulp-esnext/node_modules/esnext/node_modules/recast/lib/printer.js:923:    case "ClassHeritage": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/recast/lib/printer.js:924:    case "ComprehensionBlock": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/recast/lib/printer.js:925:    case "ComprehensionExpression": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/recast/lib/printer.js:926:    case "Glob": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/recast/lib/printer.js:927:    case "TaggedTemplateExpression": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/recast/lib/printer.js:928:    case "TemplateElement": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/recast/lib/printer.js:929:    case "TemplateLiteral": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/recast/lib/printer.js:930:    case "GeneratorExpression": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/recast/lib/printer.js:931:    case "LetStatement": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/recast/lib/printer.js:932:    case "LetExpression": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/recast/lib/printer.js:933:    case "GraphExpression": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/recast/lib/printer.js:934:    case "GraphIndexExpression": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/recast/lib/printer.js:935:    case "TypeAnnotation": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/lib/emit.js:882:  // statement without jumping to it. TODO Consider avoiding this
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/lib/visit.js:54:    // TODO Ensure $callee is not the name of any hoisted variable.
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/lib/visit.js:58:    // TODO Ensure these identifiers are named uniquely.
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/defs/build/es5/defs-main.js:244:// TODO for loops init and body props are parallel to each other but init scope is outer that of body
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/defs/build/es5/defs-main.js:245:// TODO is this a problem?
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/defs/build/es5/defs-main.js:628:    // TODO detect unused variables (never read)
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/defs/build/es5/scope.js:44:    // TODO move to decls.w?
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/defs/build/es5/scope.js:45:    // TODO create corresponding read?
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/defs/defs-main.js:244:// TODO for loops init and body props are parallel to each other but init scope is outer that of body
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/defs/defs-main.js:245:// TODO is this a problem?
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/defs/defs-main.js:628:    // TODO detect unused variables (never read)
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/defs/scope.js:44:    // TODO move to decls.w?
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/defs/scope.js:45:    // TODO create corresponding read?
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/defs/tests/forbidden-loop-closure.js:65:// TODO block-less loops (is that even applicable?)
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/lib/printer.js:617:        // TODO Get the for (;;) case right.
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/lib/printer.js:927:    case "ClassHeritage": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/lib/printer.js:928:    case "ComprehensionBlock": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/lib/printer.js:929:    case "ComprehensionExpression": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/lib/printer.js:930:    case "Glob": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/lib/printer.js:931:    case "TaggedTemplateExpression": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/lib/printer.js:932:    case "TemplateElement": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/lib/printer.js:933:    case "TemplateLiteral": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/lib/printer.js:934:    case "GeneratorExpression": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/lib/printer.js:935:    case "LetStatement": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/lib/printer.js:936:    case "LetExpression": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/lib/printer.js:937:    case "GraphExpression": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/lib/printer.js:938:    case "GraphIndexExpression": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/lib/printer.js:939:    case "TypeAnnotation": // TODO
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/node_modules/ast-types/def/core.js:54:// TODO Figure out how to silently coerce Expressions to
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/node_modules/ast-types/def/core.js:179:        def("Identifier") // TODO Esprima deviation.
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/node_modules/ast-types/def/core.js:188:// TODO Are all Expressions really Patterns?
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/node_modules/ast-types/def/core.js:203:// TODO Not in the Mozilla Parser API, but used by Esprima.
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/node_modules/ast-types/def/core.js:225:    // TODO Esprima doesn't bother with this field, presumably because
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/node_modules/ast-types/def/core.js:234:    "&", // TODO Missing from the Parser API.
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/node_modules/ast-types/def/core.js:254:    // TODO Shouldn't this be def("Pattern")?
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/node_modules/ast-types/def/core.js:289:    // TODO Report this nonsense.
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/node_modules/ast-types/def/core.js:311:    // TODO File a bug to get PropertyPattern added to the interfaces API.
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/node_modules/ast-types/def/core.js:332:    // But aren't Expressions and Patterns already Nodes? TODO Report this.
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/node_modules/ast-types/def/core.js:338:    // But aren't Expressions already Nodes? TODO Report this.
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/node_modules/ast-types/def/es6.js:15:    // TODO This could be represented as a SpreadElementPattern in .params.
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/node_modules/ast-types/def/es6.js:24:// TODO The Parser API calls this ArrowExpression, but Esprima uses
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/node_modules/ast-types/def/es6.js:33:    // liberty of enforcing that. TODO Report this.
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/node_modules/ast-types/def/fb-harmony.js:68:        def("Literal") // TODO Esprima should return XJSText instead.
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/node_modules/ast-types/def/fb-harmony.js:86:    .bases("Node") // TODO Does this make sense? Can't really be an XJSElement.
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/node_modules/ast-types/def/fb-harmony.js:93:    .bases("Node") // TODO Same concern.
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/node_modules/ast-types/def/mozilla.js:19:    // TODO Deviating from the spec by reusing VariableDeclarator here.
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/node_modules/ast-types/def/mozilla.js:26:    // TODO Deviating from the spec by reusing VariableDeclarator here.
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/node_modules/ast-types/lib/types.js:479:    // like SourceLocation, but that seems harmless (TODO?).
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/node_modules/ast-types/lib/types.js:529:                // TODO Could attach getters and setters here to enforce
node_modules/gulp-esnext/node_modules/esnext/node_modules/regenerator/node_modules/recast/node_modules/ast-types/lib/types.js:653:        // TODO Warn if fields are overridden with incompatible types.
node_modules/gulp-esnext/node_modules/esnext/package.json:51:  "readme": "# esnext\n\nUse tomorrow's JavaScript syntax today. [Try it now in your browser](http://square.github.io/esnext/).\n\n**NOTE:** This project is early alpha. Use it in production at your own risk.\nFor a more robust project with similar goals, see [Google's Traceur][traceur].\n\n## Install\n\n```\n$ npm install [--save-dev] esnext\n```\n\n## Goals\n\n* Allow using future JavaScript syntax today.\n* Require as little runtime code as possible.\n* Generate human-readable code.\n\n## Non-Goals\n\n* Provide polyfills for future JavaScript APIs.\n* Line-by-line equivalence from source to compiled.\n\n## Features\n\n### Available\n\n* [classes][features-classes] (via [es6-class][es6-class])\n* [generators][features-generators] (via [regenerator][regenerator])\n* [arrow functions][features-arrows] (via [es6-arrow-function][es6-arrow-function])\n* [template strings][features-template-strings] (via [es6-templates][es6-templates])\n* [rest params][features-default-rest-spread] (via [es6-rest-params][es6-rest-params])\n* [default params][features-default-rest-spread] (via [es6-default-params][es6-default-params])\n* [spread][features-default-rest-spread] (via [es6-spread][es6-spread])\n* [comprehensions][features-comprehensions] (via [es6-comprehensions][es6-comprehensions])\n\n### TODO\n\n* [modules][features-modules] (i.e. integration with [es6-module-transpiler][es6-module-transpiler])\n* [block scoping (`let`)][features-let-const]\n* [destructuring][features-destructuring]\n\nAny omissions here are not intentional and we'd love to integrate support for\nmore future JavaScript syntax (see [es6features][es6features] for a more\ncomplete list). See the Contributing section below. Keep in mind that, as of\nright now, this project is intended to support new JavaScript *syntax* only.\nAny new APIs should be handled using polyfills. This may change in the future.\n\n## Usage\n\n### As a CLI\n\nesnext ships with a command-line interface that can be used when installed\nglobally (or from within your project at `node_modules/.bin/esnext` when\ninstalled locally). Here's how to compile a single file an print it to stdout:\n\n```\n$ esnext myfile.js\n```\n\nIf you don't care about a certain feature, such as arrow functions, you can\nomit support for them like so:\n\n```\n$ esnext --no-arrow-function myfile.js\n```\n\nTo compile many files at once, specify an output directory:\n\n```\n$ esnext -o build lib/**/*.js\n```\n\nTo enable source maps for these files, add the `--source-maps` flag.\n\n### As a Library\n\n```js\nvar compile = require('esnext').compile;\nvar result = compile(es6Source);\nfs.writeFileSync('result.js', result.code, 'utf8');\nfs.writeFileSync('result.js.map', JSON.stringify(result.map), 'utf8');\n```\n\n### With other tools\n\nOr, use one of these libraries that integrate esnext with other tools:\n\n* [broccoli-esnext][broccoli-esnext]\n* [grunt-esnext][grunt-esnext]\n* [gulp-esnext][gulp-esnext]\n\n## Contributing\n\n[![Build Status](https://travis-ci.org/square/esnext.png?branch=master)](https://travis-ci.org/square/esnext)\n\n### Setup\n\nFirst, install the development dependencies:\n\n```\n$ npm install\n```\n\nThen, try running the tests:\n\n```\n$ npm test\n```\n\n### Pull Requests\n\n1. Fork it\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create new Pull Request\n\nAny contributors to the master esnext repository must sign the [Individual\nContributor License Agreement (CLA)][cla].  It's a short form that covers our\nbases and makes sure you're eligible to contribute.\n\n[cla]: https://spreadsheets.google.com/spreadsheet/viewform?formkey=dDViT2xzUHAwRkI3X3k5Z0lQM091OGc6MQ&ndplr=1\n\nWhen you have a change you'd like to see in the master repository, [send a pull\nrequest](https://github.com/square/esnext/pulls). Before we merge your\nrequest, we'll make sure you're in the list of people who have signed a CLA.\n\n## Acknowledgements\n\nHuge thanks to [Ben Newman][benjamn] for [recast][recast] and\n[regenerator][regenerator]. Thanks to [Ariya Hidayat][ariya] for\n[esprima][esprima]. Thanks also to [Thomas Boyt][thomasboyt] for his work on\nthe [es6-module-transpiler][es6-module-transpiler], [es6-class][es6-class],\n[es6-arrow-function][es6-arrow-function], and others.\n\n[ariya]: https://github.com/ariya\n[benjamn]: https://github.com/benjamn\n[broccoli-esnext]: https://github.com/shinnn/broccoli-esnext\n[broccoli]: https://github.com/joliss/broccoli\n[es6-arrow-function]: https://github.com/square/es6-arrow-function\n[es6-class]: https://github.com/square/es6-class\n[es6-comprehensions]: https://github.com/dreame4/es6-comprehensions\n[es6-default-params]: https://github.com/square/es6-default-params\n[es6-module-transpiler]: https://github.com/square/es6-module-transpiler\n[es6-rest-params]: https://github.com/thomasboyt/es6-rest-params\n[es6-spread]: https://github.com/square/es6-spread\n[es6-templates]: https://github.com/square/es6-templates\n[es6features]: https://github.com/lukehoban/es6features\n[esprima]: https://github.com/ariya/esprima\n[features-arrows]: https://github.com/lukehoban/es6features#arrows\n[features-classes]: https://github.com/lukehoban/es6features#classes\n[features-comprehensions]: https://github.com/lukehoban/es6features#comprehensions\n[features-default-rest-spread]: https://github.com/lukehoban/es6features#default--rest--spread\n[features-destructuring]: https://github.com/lukehoban/es6features#destructuring\n[features-generators]: https://github.com/lukehoban/es6features#generators\n[features-let-const]: https://github.com/lukehoban/es6features#let--const\n[features-modules]: https://github.com/lukehoban/es6features#modules\n[features-template-strings]: https://github.com/lukehoban/es6features#template-strings\n[grunt-esnext]: https://github.com/shinnn/grunt-esnext\n[gulp-esnext]: https://github.com/sindresorhus/gulp-esnext\n[recast]: https://github.com/benjamn/recast\n[regenerator]: http://facebook.github.io/regenerator/\n[thomasboyt]: http://www.thomasboyt.com/\n[traceur]: https://github.com/google/traceur-compiler\n",
node_modules/gulp-esnext/node_modules/esnext/README.md:38:### TODO
node_modules/gulp-esnext/node_modules/gulp-util/lib/PluginError.js:49:  // TODO: figure out why this explodes mocha
node_modules/gulp-esnext/node_modules/gulp-util/node_modules/multipipe/node_modules/duplexer2/node_modules/readable-stream/lib/_stream_writable.js:157:  // TODO: defer error events consistently everywhere, not just the cb
node_modules/gulp-esnext/node_modules/gulp-util/node_modules/multipipe/node_modules/duplexer2/node_modules/readable-stream/lib/_stream_writable.js:360:    // TODO(isaacs) clean this up
node_modules/gulp-esnext/node_modules/gulp-util/node_modules/vinyl/index.js:14:  // TODO: should this be moved to vinyl-fs?
node_modules/gulp-esnext/node_modules/gulp-util/node_modules/vinyl/index.js:21:  // TODO: should this be moved to vinyl-fs?
node_modules/gulp-esnext/node_modules/gulp-util/node_modules/vinyl/index.js:40:// TODO: should this be moved to vinyl-fs?
node_modules/gulp-esnext/node_modules/gulp-util/node_modules/vinyl/index.js:116:// TODO: should this be moved to vinyl-fs?
node_modules/gulp-esnext/node_modules/through2/node_modules/readable-stream/lib/_stream_writable.js:146:  // TODO: defer error events consistently everywhere, not just the cb
node_modules/gulp-livereload/node_modules/gulp-util/lib/PluginError.js:49:  // TODO: figure out why this explodes mocha
node_modules/gulp-livereload/node_modules/gulp-util/node_modules/multipipe/node_modules/duplexer2/node_modules/readable-stream/lib/_stream_writable.js:157:  // TODO: defer error events consistently everywhere, not just the cb
node_modules/gulp-livereload/node_modules/gulp-util/node_modules/multipipe/node_modules/duplexer2/node_modules/readable-stream/lib/_stream_writable.js:360:    // TODO(isaacs) clean this up
node_modules/gulp-livereload/node_modules/gulp-util/node_modules/through2/node_modules/readable-stream/lib/_stream_writable.js:146:  // TODO: defer error events consistently everywhere, not just the cb
node_modules/gulp-livereload/node_modules/gulp-util/node_modules/vinyl/index.js:14:  // TODO: should this be moved to vinyl-fs?
node_modules/gulp-livereload/node_modules/gulp-util/node_modules/vinyl/index.js:21:  // TODO: should this be moved to vinyl-fs?
node_modules/gulp-livereload/node_modules/gulp-util/node_modules/vinyl/index.js:40:// TODO: should this be moved to vinyl-fs?
node_modules/gulp-livereload/node_modules/gulp-util/node_modules/vinyl/index.js:116:// TODO: should this be moved to vinyl-fs?
node_modules/gulp-livereload/node_modules/tiny-lr/node_modules/qs/test/browser/jquery.js:1472:			// TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
node_modules/gulp-livereload/node_modules/tiny-lr/node_modules/qs/test/browser/jquery.js:1507:		// TODO: This is a hack for 1.5 ONLY. It will be removed in 1.6. Users should
node_modules/gulp-livereload/node_modules/tiny-lr/node_modules/qs/test/browser/jquery.js:1580:			// TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
node_modules/gulp-livereload/node_modules/tiny-lr/node_modules/qs/test/browser/jquery.js:1718:// TODO: This is a hack for 1.5 ONLY to allow objects with a single toJSON
node_modules/gulp-livereload/node_modules/tiny-lr/node_modules/qs/test/browser/jquery.js:2856:			// TODO: Stop taunting the data cache; remove global events and always attach to document
node_modules/gulp-livereload/node_modules/tiny-lr/node_modules/qs/test/browser/jquery.js:4263:			// TODO: Move to normal caching system
node_modules/gulp-livereload/node_modules/tiny-lr/node_modules/qs/test/browser/mocha.js:1693:    // TODO: add to stats
node_modules/gulp-livereload/node_modules/tiny-lr/node_modules/qs/test/browser/mocha.js:1739:    // TODO: defer
node_modules/gulp-sourcemaps/node_modules/through2/node_modules/readable-stream/lib/_stream_writable.js:146:  // TODO: defer error events consistently everywhere, not just the cb
node_modules/gulp-sourcemaps/node_modules/vinyl/index.js:14:  // TODO: should this be moved to vinyl-fs?
node_modules/gulp-sourcemaps/node_modules/vinyl/index.js:21:  // TODO: should this be moved to vinyl-fs?
node_modules/gulp-sourcemaps/node_modules/vinyl/index.js:40:// TODO: should this be moved to vinyl-fs?
node_modules/gulp-sourcemaps/node_modules/vinyl/index.js:116:// TODO: should this be moved to vinyl-fs?
node_modules/gulp-traceur/node_modules/gulp-util/lib/PluginError.js:49:  // TODO: figure out why this explodes mocha
node_modules/gulp-traceur/node_modules/gulp-util/node_modules/multipipe/node_modules/duplexer2/node_modules/readable-stream/lib/_stream_writable.js:157:  // TODO: defer error events consistently everywhere, not just the cb
node_modules/gulp-traceur/node_modules/gulp-util/node_modules/multipipe/node_modules/duplexer2/node_modules/readable-stream/lib/_stream_writable.js:360:    // TODO(isaacs) clean this up
node_modules/gulp-traceur/node_modules/gulp-util/node_modules/vinyl/index.js:14:  // TODO: should this be moved to vinyl-fs?
node_modules/gulp-traceur/node_modules/gulp-util/node_modules/vinyl/index.js:21:  // TODO: should this be moved to vinyl-fs?
node_modules/gulp-traceur/node_modules/gulp-util/node_modules/vinyl/index.js:40:// TODO: should this be moved to vinyl-fs?
node_modules/gulp-traceur/node_modules/gulp-util/node_modules/vinyl/index.js:116:// TODO: should this be moved to vinyl-fs?
node_modules/gulp-traceur/node_modules/through2/node_modules/readable-stream/lib/_stream_writable.js:146:  // TODO: defer error events consistently everywhere, not just the cb
node_modules/gulp-traceur/node_modules/traceur/node_modules/glob/node_modules/minimatch/test/basic.js:3:// TODO: Some of these tests do very bad things with backslashes, and will
node_modules/gulp-traceur/node_modules/traceur/node_modules/glob/node_modules/minimatch/test/defaults.js:3:// TODO: Some of these tests do very bad things with backslashes, and will
node_modules/gulp-traceur/node_modules/traceur/src/node/command.js:113:  // TODO: Start trepl
node_modules/gulp-traceur/node_modules/traceur/src/node/deferred.js:103:  // TODO: find and wrap everything that needs to be wrapped.
node_modules/karma/lib/browser.js:78:    // TODO(vojta): move to collection
node_modules/karma/lib/browser.js:108:    // TODO(vojta): remove
node_modules/karma/lib/browser.js:186:      // TODO(vojta): move to collection
node_modules/karma/lib/browser_collection.js:76:  // TODO(vojta): can we remove this? (we clear the results per browser in onBrowserStart)
node_modules/karma/lib/cli.js:19:  // TODO(vojta): warn/throw when unknown argument (probably mispelled)
node_modules/karma/lib/events.js:61:// TODO(vojta): log.debug all events
node_modules/karma/lib/events.js:66:    // TODO(vojta): allow passing args
node_modules/karma/lib/events.js:67:    // TODO(vojta): ignore/throw if listener call done() multiple times
node_modules/karma/lib/file_list.js:64:// TODO(vojta): ignore changes (add/change/remove) when in the middle of refresh
node_modules/karma/lib/file_list.js:65:// TODO(vojta): do not glob patterns that are watched (both on init and refresh)
node_modules/karma/lib/file_list.js:143:    // TODO(vojta): cancel refresh if another refresh starts
node_modules/karma/lib/file_list.js:157:    // TODO(vojta): use some async helper library for this
node_modules/karma/lib/file_list.js:216:                // TODO(vojta): reuse file objects
node_modules/karma/lib/file_list.js:311:          // TODO(vojta): ignore if refresh/reload happens
node_modules/karma/lib/file_list.js:365:        // TODO(vojta): THIS CAN MAKE FILES INCONSISTENT
node_modules/karma/lib/file_list.js:379:          // TODO(vojta): ignore if refresh/reload happens
node_modules/karma/lib/helper.js:84:  // TODO(vojta): handle if it's a file
node_modules/karma/lib/init.js:17:// TODO(vojta): coverage
node_modules/karma/lib/init.js:18:// TODO(vojta): html preprocessors
node_modules/karma/lib/init.js:19:// TODO(vojta): SauceLabs
node_modules/karma/lib/init.js:20:// TODO(vojta): BrowserStack
node_modules/karma/lib/init.js:78:  // TODO(vojta): check if the path resolves to a binary
node_modules/karma/lib/launcher.js:10:// TODO(vojta): remove once nobody uses it
node_modules/karma/lib/launcher.js:52:      // TODO(vojta): determine script from name
node_modules/karma/lib/launcher.js:70:      // TODO(vojta): remove in v1.0 (BC for old launchers)
node_modules/karma/lib/launchers/base.js:22:  // TODO(vojta): figure out how to do inheritance with DI
node_modules/karma/lib/middleware/karma.js:106:              // TODO(vojta): serve these files from within urlRoot as well
node_modules/karma/lib/middleware/karma.js:125:          // TODO(vojta): don't compute if it's not in the template
node_modules/karma/lib/middleware/runner.js:13:// TODO(vojta): disable when single-run mode
node_modules/karma/lib/middleware/source_files.js:25:    // TODO(vojta): serve files under urlRoot (also update the formatError)
node_modules/karma/lib/middleware/source_files.js:33:    // TODO(vojta): remove once we don't care about Node 0.8
node_modules/karma/lib/middleware/source_files.js:37:      // TODO(vojta): change served to be a map rather then an array
node_modules/karma/lib/preprocessor.js:30:// TODO(vojta): instantiate preprocessors at the start to show warnings immediately
node_modules/karma/lib/preprocessor.js:79:    // TODO(vojta): should we cache this ?
node_modules/karma/lib/reporter.js:72:  // TODO(vojta): instantiate all reporters through DI
node_modules/karma/lib/reporters/base.js:67:      // TODO(vojta): change util to new syntax (config object)
node_modules/karma/lib/runner.js:27:// TODO(vojta): read config file (port, host, urlRoot)
node_modules/karma/lib/server.js:76:    // TODO(vojta): send only to interested browsers
node_modules/karma/lib/server.js:83:    // TODO(vojta): This is lame, browser can get captured and then crash (before other browsers get
node_modules/karma/lib/server.js:197:    // TODO(vojta): change the client to not send the event (if disconnected by purpose)
node_modules/karma/lib/server.js:295:    // TODO(vojta): remove
node_modules/karma/lib/server.js:297:    // TODO(vojta): remove, once karma-dart does not rely on it
node_modules/karma/lib/web-server.js:53:      // TODO(vojta): extract the proxy into a plugin
node_modules/karma/lib/web-server.js:55:      // TODO(vojta): remove, this is only here because of karma-dart
node_modules/karma/node_modules/chokidar/node_modules/fsevents/build/gyp-mac-tool:55:      # TODO(thakis): This copies file attributes like mtime, while the
node_modules/karma/node_modules/chokidar/node_modules/fsevents/build/Makefile:62:# TODO(evan): move all cross-compilation logic to gyp-time so we don't need
node_modules/karma/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan.h:310://TODO: remove <0.11.8 support when 0.12 is released
node_modules/karma/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan.h:330://TODO: remove <0.11.9 support when 0.12 is released
node_modules/karma/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan.h:388://TODO: remove <0.11.8 support when 0.12 is released
node_modules/karma/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan.h:1078:      // TODO(isaacs): THIS IS AWFUL!!!
node_modules/karma/node_modules/connect/lib/middleware/cookieSession.js:52:  // TODO: utilize Session/Cookie to unify API
node_modules/karma/node_modules/connect/lib/middleware/cookieSession.js:76:      // TODO: refactor
node_modules/karma/node_modules/connect/lib/middleware/directory.js:9:// TODO: arrow key navigation
node_modules/karma/node_modules/connect/lib/middleware/directory.js:10:// TODO: make icons extensible
node_modules/karma/node_modules/connect/lib/middleware/staticCache.js:73:    // TODO: change from staticCache() -> cache()
node_modules/karma/node_modules/connect/lib/middleware/staticCache.js:94:      // TODO: real support for must-revalidate / no-cache
node_modules/karma/node_modules/connect/lib/middleware/staticCache.js:124:        delete headers['x-cache']; // Clean up (TODO: others)
node_modules/karma/node_modules/connect/lib/middleware/staticCache.js:149: * TODO: Assume 200 code, that's iffy.
node_modules/karma/node_modules/connect/node_modules/multiparty/node_modules/readable-stream/lib/_stream_writable.js:157:  // TODO: defer error events consistently everywhere, not just the cb
node_modules/karma/node_modules/connect/node_modules/multiparty/node_modules/readable-stream/lib/_stream_writable.js:360:    // TODO(isaacs) clean this up
node_modules/karma/node_modules/connect/node_modules/send/lib/send.js:409:  // TODO: this is all lame, refactor meeee
node_modules/karma/node_modules/di/lib/injector.js:74:    // TODO(vojta): optimize without apply
node_modules/karma/node_modules/di/lib/injector.js:105:    // TODO(vojta): handle wrong inputs (modules)
node_modules/karma/node_modules/glob/node_modules/minimatch/test/basic.js:3:// TODO: Some of these tests do very bad things with backslashes, and will
node_modules/karma/node_modules/glob/node_modules/minimatch/test/defaults.js:3:// TODO: Some of these tests do very bad things with backslashes, and will
node_modules/karma/node_modules/http-proxy/examples/helpers/store.js:20:// TODO: cached map-reduce views and auto-magic sharding.
node_modules/karma/node_modules/http-proxy/lib/node-http-proxy/routing-proxy.js:87:  // TODO: Consume properties in `options` related to the `ProxyTable`.
node_modules/karma/node_modules/http-proxy/node_modules/utile/node_modules/i/package.json:57:  "readme": "# inflect\n\ncustomizable inflections for nodejs\n\n## Installation\n\n```bash\nnpm install i\n```\n\n## Usage\n\nRequire the module before using\n\n```js\nvar inflect = require('i')();\n```\n\nAll the below api functions can be called directly on a string\n\n```js\ninflect.titleize('messages to store') // === 'Messages To Store'\n'messages to store'.titleize // === 'Messages To Store'\n```\n\nonly if `true` is passed while initiating\n\n```js\nvar inflect = require('i')(true);\n```\n\n### Pluralize\n\n```js\ninflect.pluralize('person'); // === 'people'\ninflect.pluralize('octopus'); // === 'octopi'\ninflect.pluralize('Hat'); // === 'Hats'\n```\n\n### Singularize\n\n```js\ninflect.singularize('people'); // === 'person'\ninflect.singularize('octopi'); // === 'octopus'\ninflect.singularize('Hats'); // === 'Hat'\n```\n\n### Camelize\n\n```js\ninflect.camelize('message_properties'); // === 'MessageProperties'\ninflect.camelize('message_properties', false); // === 'messageProperties'\n```\n\n### Underscore\n\n```js\ninflect.underscore('MessageProperties'); // === 'message_properties'\ninflect.underscore('messageProperties'); // === 'message_properties'\n```\n\n### Humanize\n\n```js\ninflect.humanize('message_id'); // === 'Message'\n```\n\n### Dasherize\n\n```js\ninflect.dasherize('message_properties'); // === 'message-properties'\ninflect.dasherize('Message Properties'); // === 'Message Properties'\n```\n\n### Titleize\n\n```js\ninflect.titleize('message_properties'); // === 'Message Properties'\ninflect.titleize('message properties to keep'); // === 'Message Properties to Keep'\n```\n\n### Demodulize\n\n```js\ninflect.demodulize('Message.Bus.Properties'); // === 'Properties'\n```\n\n### Tableize\n\n```js\ninflect.tableize('MessageBusProperty'); // === 'message_bus_properties'\n```\n\n### Classify\n\n```js\ninflect.classify('message_bus_properties'); // === 'MessageBusProperty'\n```\n\n### Foreign key\n\n```js\ninflect.foreign_key('MessageBusProperty'); // === 'message_bus_property_id'\ninflect.foreign_key('MessageBusProperty', false); // === 'message_bus_propertyid'\n```\n\n### Ordinalize\n\n```js\ninflect.ordinalize( '1' ); // === '1st'\n```\n\n## Custom rules for inflection\n\n### Custom plural\n\nWe can use regexp in any of these custom rules\n\n```js\ninflect.inflections.plural('person', 'guys');\ninflect.pluralize('person'); // === 'guys'\ninflect.singularize('guys'); // === 'guy'\n```\n\n### Custom singular\n\n```js\ninflect.inflections.singular('guys', 'person')\ninflect.singularize('guys'); // === 'person'\ninflect.pluralize('person'); // === 'people'\n```\n\n### Custom irregular\n\n```js\ninflect.inflections.irregular('person', 'guys')\ninflect.pluralize('person'); // === 'guys'\ninflect.singularize('guys'); // === 'person'\n```\n\n### Custom human\n\n```js\ninflect.inflections.human(/^(.*)_cnt$/i, '$1_count');\ninflect.inflections.humanize('jargon_cnt'); // === 'Jargon count'\n```\n\n### Custom uncountable\n\n```js\ninflect.inflections.uncountable('oil')\ninflect.pluralize('oil'); // === 'oil'\ninflect.singularize('oil'); // === 'oil'\n```\n\n## Contributors\nHere is a list of [Contributors](http://github.com/pksunkara/inflect/contributors)\n\n### TODO\n\n- More obscure test cases\n\n__I accept pull requests and guarantee a reply back within a day__\n\n## License\nMIT/X11\n\n## Bug Reports\nReport [here](http://github.com/pksunkara/inflect/issues). __Guaranteed reply within a day__.\n\n## Contact\nPavan Kumar Sunkara (pavan.sss1991@gmail.com)\n\nFollow me on [github](https://github.com/users/follow?target=pksunkara), [twitter](http://twitter.com/pksunkara)\n",
node_modules/karma/node_modules/http-proxy/node_modules/utile/node_modules/i/README.md:159:### TODO
node_modules/karma/node_modules/log4js/node_modules/async/deps/nodeunit.js:1179:// TODO: test what effect this may have
node_modules/karma/node_modules/log4js/node_modules/async/deps/nodeunit.js:1736:// TODO: add proper unit tests for this function
node_modules/karma/node_modules/log4js/node_modules/readable-stream/lib/_stream_writable.js:146:  // TODO: defer error events consistently everywhere, not just the cb
node_modules/karma/node_modules/minimatch/test/basic.js:3:// TODO: Some of these tests do very bad things with backslashes, and will
node_modules/karma/node_modules/minimatch/test/defaults.js:3:// TODO: Some of these tests do very bad things with backslashes, and will
node_modules/karma/node_modules/q/q.js:689:            // TODO: "===" should be Object.is or equiv
node_modules/karma/node_modules/q/q.js:1658:        // TODO attempt to recycle the rejection with "this".
node_modules/karma/node_modules/socket.io/node_modules/redis/index.js:169:                }, 2000); // TODO - magic number alert
node_modules/karma/node_modules/socket.io/node_modules/redis/index.js:442:        // TODO - some people need a "Redis is Broken mode" for future commands that errors immediately, and others
node_modules/karma/node_modules/socket.io/node_modules/redis/index.js:462:            // TODO - engage Redis is Broken mode for future commands, or whatever
node_modules/karma/node_modules/socket.io/node_modules/redis/index.js:483:        // TODO - it might be nice to have a different "error" event for different types of errors
node_modules/karma/node_modules/socket.io/node_modules/redis/index.js:587:            // TODO - confusing and error-prone that hgetall is special cased in two places
node_modules/karma/node_modules/socket.io/node_modules/redis/index.js:614:                // TODO - document this or fix it so it works in a more obvious way
node_modules/karma/node_modules/socket.io/node_modules/redis/index.js:988:    // TODO - get rid of all of these anonymous functions which are elegant but slow
node_modules/karma/node_modules/socket.io/node_modules/redis/index.js:1019:    // TODO - make this callback part of Multi.prototype instead of creating it each time
node_modules/karma/node_modules/socket.io/node_modules/redis/index.js:1037:                // TODO - confusing and error-prone that hgetall is special cased in two places
node_modules/karma/node_modules/socket.io/node_modules/redis/lib/parser/javascript.js:3:// TODO - incorporate these V8 pro tips:
node_modules/karma/node_modules/socket.io/node_modules/redis/lib/parser/javascript.js:263:        // TODO - can this happen?  Seems like maybe not.
node_modules/karma/node_modules/socket.io/node_modules/redis/package.json:27:  "readme": "redis - a node.js redis client\n===========================\n\nThis is a complete Redis client for node.js.  It supports all Redis commands, including many recently added commands like EVAL from\nexperimental Redis server branches.\n\n\nInstall with:\n\n    npm install redis\n\nPieter Noordhuis has provided a binding to the official `hiredis` C library, which is non-blocking and fast.  To use `hiredis`, do:\n\n    npm install hiredis redis\n\nIf `hiredis` is installed, `node_redis` will use it by default.  Otherwise, a pure JavaScript parser will be used.\n\nIf you use `hiredis`, be sure to rebuild it whenever you upgrade your version of node.  There are mysterious failures that can\nhappen between node and native code modules after a node upgrade.\n\n\n## Usage\n\nSimple example, included as `examples/simple.js`:\n\n```js\n    var redis = require(\"redis\"),\n        client = redis.createClient();\n\n    // if you'd like to select database 3, instead of 0 (default), call\n    // client.select(3, function() { /* ... */ });\n\n    client.on(\"error\", function (err) {\n        console.log(\"Error \" + err);\n    });\n\n    client.set(\"string key\", \"string val\", redis.print);\n    client.hset(\"hash key\", \"hashtest 1\", \"some value\", redis.print);\n    client.hset([\"hash key\", \"hashtest 2\", \"some other value\"], redis.print);\n    client.hkeys(\"hash key\", function (err, replies) {\n        console.log(replies.length + \" replies:\");\n        replies.forEach(function (reply, i) {\n            console.log(\"    \" + i + \": \" + reply);\n        });\n        client.quit();\n    });\n```\n\nThis will display:\n\n    mjr:~/work/node_redis (master)$ node example.js\n    Reply: OK\n    Reply: 0\n    Reply: 0\n    2 replies:\n        0: hashtest 1\n        1: hashtest 2\n    mjr:~/work/node_redis (master)$\n\n\n## Performance\n\nHere are typical results of `multi_bench.js` which is similar to `redis-benchmark` from the Redis distribution.\nIt uses 50 concurrent connections with no pipelining.\n\nJavaScript parser:\n\n    PING: 20000 ops 42283.30 ops/sec 0/5/1.182\n    SET: 20000 ops 32948.93 ops/sec 1/7/1.515\n    GET: 20000 ops 28694.40 ops/sec 0/9/1.740\n    INCR: 20000 ops 39370.08 ops/sec 0/8/1.269\n    LPUSH: 20000 ops 36429.87 ops/sec 0/8/1.370\n    LRANGE (10 elements): 20000 ops 9891.20 ops/sec 1/9/5.048\n    LRANGE (100 elements): 20000 ops 1384.56 ops/sec 10/91/36.072\n\nhiredis parser:\n\n    PING: 20000 ops 46189.38 ops/sec 1/4/1.082\n    SET: 20000 ops 41237.11 ops/sec 0/6/1.210\n    GET: 20000 ops 39682.54 ops/sec 1/7/1.257\n    INCR: 20000 ops 40080.16 ops/sec 0/8/1.242\n    LPUSH: 20000 ops 41152.26 ops/sec 0/3/1.212\n    LRANGE (10 elements): 20000 ops 36563.07 ops/sec 1/8/1.363\n    LRANGE (100 elements): 20000 ops 21834.06 ops/sec 0/9/2.287\n\nThe performance of `node_redis` improves dramatically with pipelining, which happens automatically in most normal programs.\n\n\n### Sending Commands\n\nEach Redis command is exposed as a function on the `client` object.\nAll functions take either an `args` Array plus optional `callback` Function or\na variable number of individual arguments followed by an optional callback.\nHere is an example of passing an array of arguments and a callback:\n\n    client.mset([\"test keys 1\", \"test val 1\", \"test keys 2\", \"test val 2\"], function (err, res) {});\n\nHere is that same call in the second style:\n\n    client.mset(\"test keys 1\", \"test val 1\", \"test keys 2\", \"test val 2\", function (err, res) {});\n\nNote that in either form the `callback` is optional:\n\n    client.set(\"some key\", \"some val\");\n    client.set([\"some other key\", \"some val\"]);\n\nIf the key is missing, reply will be null (probably):\n\n    client.get(\"missingkey\", function(err, reply) {\n        // reply is null when the key is missing\n        console.log(reply);\n    });\n\nFor a list of Redis commands, see [Redis Command Reference](http://redis.io/commands)\n\nThe commands can be specified in uppercase or lowercase for convenience.  `client.get()` is the same as `client.GET()`.\n\nMinimal parsing is done on the replies.  Commands that return a single line reply return JavaScript Strings,\ninteger replies return JavaScript Numbers, \"bulk\" replies return node Buffers, and \"multi bulk\" replies return a\nJavaScript Array of node Buffers.  `HGETALL` returns an Object with Buffers keyed by the hash keys.\n\n# API\n\n## Connection Events\n\n`client` will emit some events about the state of the connection to the Redis server.\n\n### \"ready\"\n\n`client` will emit `ready` a connection is established to the Redis server and the server reports\nthat it is ready to receive commands.  Commands issued before the `ready` event are queued,\nthen replayed just before this event is emitted.\n\n### \"connect\"\n\n`client` will emit `connect` at the same time as it emits `ready` unless `client.options.no_ready_check`\nis set.  If this options is set, `connect` will be emitted when the stream is connected, and then\nyou are free to try to send commands.\n\n### \"error\"\n\n`client` will emit `error` when encountering an error connecting to the Redis server.\n\nNote that \"error\" is a special event type in node.  If there are no listeners for an\n\"error\" event, node will exit.  This is usually what you want, but it can lead to some\ncryptic error messages like this:\n\n    mjr:~/work/node_redis (master)$ node example.js\n\n    node.js:50\n        throw e;\n        ^\n    Error: ECONNREFUSED, Connection refused\n        at IOWatcher.callback (net:870:22)\n        at node.js:607:9\n\nNot very useful in diagnosing the problem, but if your program isn't ready to handle this,\nit is probably the right thing to just exit.\n\n`client` will also emit `error` if an exception is thrown inside of `node_redis` for whatever reason.\nIt would be nice to distinguish these two cases.\n\n### \"end\"\n\n`client` will emit `end` when an established Redis server connection has closed.\n\n### \"drain\"\n\n`client` will emit `drain` when the TCP connection to the Redis server has been buffering, but is now\nwritable.  This event can be used to stream commands in to Redis and adapt to backpressure.  Right now,\nyou need to check `client.command_queue.length` to decide when to reduce your send rate.  Then you can\nresume sending when you get `drain`.\n\n### \"idle\"\n\n`client` will emit `idle` when there are no outstanding commands that are awaiting a response.\n\n## redis.createClient(port, host, options)\n\nCreate a new client connection.  `port` defaults to `6379` and `host` defaults\nto `127.0.0.1`.  If you have `redis-server` running on the same computer as node, then the defaults for\nport and host are probably fine.  `options` in an object with the following possible properties:\n\n* `parser`: which Redis protocol reply parser to use.  Defaults to `hiredis` if that module is installed.\nThis may also be set to `javascript`.\n* `return_buffers`: defaults to `false`.  If set to `true`, then all replies will be sent to callbacks as node Buffer\nobjects instead of JavaScript Strings.\n* `detect_buffers`: default to `false`. If set to `true`, then replies will be sent to callbacks as node Buffer objects\nif any of the input arguments to the original command were Buffer objects.\nThis option lets you switch between Buffers and Strings on a per-command basis, whereas `return_buffers` applies to\nevery command on a client.\n* `socket_nodelay`: defaults to `true`. Whether to call setNoDelay() on the TCP stream, which disables the\nNagle algorithm on the underlying socket.  Setting this option to `false` can result in additional throughput at the\ncost of more latency.  Most applications will want this set to `true`.\n* `no_ready_check`: defaults to `false`. When a connection is established to the Redis server, the server might still\nbe loading the database from disk.  While loading, the server not respond to any commands.  To work around this,\n`node_redis` has a \"ready check\" which sends the `INFO` command to the server.  The response from the `INFO` command\nindicates whether the server is ready for more commands.  When ready, `node_redis` emits a `ready` event.\nSetting `no_ready_check` to `true` will inhibit this check.\n* `enable_offline_queue`: defaults to `true`. By default, if there is no active\nconnection to the redis server, commands are added to a queue and are executed\nonce the connection has been established. Setting `enable_offline_queue` to\n`false` will disable this feature and the callback will be execute immediately\nwith an error, or an error will be thrown if no callback is specified.\n\n```js\n    var redis = require(\"redis\"),\n        client = redis.createClient(null, null, {detect_buffers: true});\n\n    client.set(\"foo_rand000000000000\", \"OK\");\n\n    // This will return a JavaScript String\n    client.get(\"foo_rand000000000000\", function (err, reply) {\n        console.log(reply.toString()); // Will print `OK`\n    });\n\n    // This will return a Buffer since original key is specified as a Buffer\n    client.get(new Buffer(\"foo_rand000000000000\"), function (err, reply) {\n        console.log(reply.toString()); // Will print `<Buffer 4f 4b>`\n    });\n    client.end();\n```\n\n`createClient()` returns a `RedisClient` object that is named `client` in all of the examples here.\n\n## client.auth(password, callback)\n\nWhen connecting to Redis servers that require authentication, the `AUTH` command must be sent as the\nfirst command after connecting.  This can be tricky to coordinate with reconnections, the ready check,\netc.  To make this easier, `client.auth()` stashes `password` and will send it after each connection,\nincluding reconnections.  `callback` is invoked only once, after the response to the very first\n`AUTH` command sent.\nNOTE: Your call to `client.auth()` should not be inside the ready handler. If\nyou are doing this wrong, `client` will emit an error that looks\nsomething like this `Error: Ready check failed: ERR operation not permitted`.\n\n## client.end()\n\nForcibly close the connection to the Redis server.  Note that this does not wait until all replies have been parsed.\nIf you want to exit cleanly, call `client.quit()` to send the `QUIT` command after you have handled all replies.\n\nThis example closes the connection to the Redis server before the replies have been read.  You probably don't\nwant to do this:\n\n```js\n    var redis = require(\"redis\"),\n        client = redis.createClient();\n\n    client.set(\"foo_rand000000000000\", \"some fantastic value\");\n    client.get(\"foo_rand000000000000\", function (err, reply) {\n        console.log(reply.toString());\n    });\n    client.end();\n```\n\n`client.end()` is useful for timeout cases where something is stuck or taking too long and you want\nto start over.\n\n## Friendlier hash commands\n\nMost Redis commands take a single String or an Array of Strings as arguments, and replies are sent back as a single String or an Array of Strings.\nWhen dealing with hash values, there are a couple of useful exceptions to this.\n\n### client.hgetall(hash)\n\nThe reply from an HGETALL command will be converted into a JavaScript Object by `node_redis`.  That way you can interact\nwith the responses using JavaScript syntax.\n\nExample:\n\n    client.hmset(\"hosts\", \"mjr\", \"1\", \"another\", \"23\", \"home\", \"1234\");\n    client.hgetall(\"hosts\", function (err, obj) {\n        console.dir(obj);\n    });\n\nOutput:\n\n    { mjr: '1', another: '23', home: '1234' }\n\n### client.hmset(hash, obj, [callback])\n\nMultiple values in a hash can be set by supplying an object:\n\n    client.HMSET(key2, {\n        \"0123456789\": \"abcdefghij\", // NOTE: the key and value must both be strings\n        \"some manner of key\": \"a type of value\"\n    });\n\nThe properties and values of this Object will be set as keys and values in the Redis hash.\n\n### client.hmset(hash, key1, val1, ... keyn, valn, [callback])\n\nMultiple values may also be set by supplying a list:\n\n    client.HMSET(key1, \"0123456789\", \"abcdefghij\", \"some manner of key\", \"a type of value\");\n\n\n## Publish / Subscribe\n\nHere is a simple example of the API for publish / subscribe.  This program opens two\nclient connections, subscribes to a channel on one of them, and publishes to that\nchannel on the other:\n\n```js\n    var redis = require(\"redis\"),\n        client1 = redis.createClient(), client2 = redis.createClient(),\n        msg_count = 0;\n\n    client1.on(\"subscribe\", function (channel, count) {\n        client2.publish(\"a nice channel\", \"I am sending a message.\");\n        client2.publish(\"a nice channel\", \"I am sending a second message.\");\n        client2.publish(\"a nice channel\", \"I am sending my last message.\");\n    });\n\n    client1.on(\"message\", function (channel, message) {\n        console.log(\"client1 channel \" + channel + \": \" + message);\n        msg_count += 1;\n        if (msg_count === 3) {\n            client1.unsubscribe();\n            client1.end();\n            client2.end();\n        }\n    });\n\n    client1.incr(\"did a thing\");\n    client1.subscribe(\"a nice channel\");\n```\n\nWhen a client issues a `SUBSCRIBE` or `PSUBSCRIBE`, that connection is put into \"pub/sub\" mode.\nAt that point, only commands that modify the subscription set are valid.  When the subscription\nset is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in pub/sub mode, just open another connection.\n\n## Pub / Sub Events\n\nIf a client has subscriptions active, it may emit these events:\n\n### \"message\" (channel, message)\n\nClient will emit `message` for every message received that matches an active subscription.\nListeners are passed the channel name as `channel` and the message Buffer as `message`.\n\n### \"pmessage\" (pattern, channel, message)\n\nClient will emit `pmessage` for every message received that matches an active subscription pattern.\nListeners are passed the original pattern used with `PSUBSCRIBE` as `pattern`, the sending channel\nname as `channel`, and the message Buffer as `message`.\n\n### \"subscribe\" (channel, count)\n\nClient will emit `subscribe` in response to a `SUBSCRIBE` command.  Listeners are passed the\nchannel name as `channel` and the new count of subscriptions for this client as `count`.\n\n### \"psubscribe\" (pattern, count)\n\nClient will emit `psubscribe` in response to a `PSUBSCRIBE` command.  Listeners are passed the\noriginal pattern as `pattern`, and the new count of subscriptions for this client as `count`.\n\n### \"unsubscribe\" (channel, count)\n\nClient will emit `unsubscribe` in response to a `UNSUBSCRIBE` command.  Listeners are passed the\nchannel name as `channel` and the new count of subscriptions for this client as `count`.  When\n`count` is 0, this client has left pub/sub mode and no more pub/sub events will be emitted.\n\n### \"punsubscribe\" (pattern, count)\n\nClient will emit `punsubscribe` in response to a `PUNSUBSCRIBE` command.  Listeners are passed the\nchannel name as `channel` and the new count of subscriptions for this client as `count`.  When\n`count` is 0, this client has left pub/sub mode and no more pub/sub events will be emitted.\n\n## client.multi([commands])\n\n`MULTI` commands are queued up until an `EXEC` is issued, and then all commands are run atomically by\nRedis.  The interface in `node_redis` is to return an individual `Multi` object by calling `client.multi()`.\n\n```js\n    var redis  = require(\"./index\"),\n        client = redis.createClient(), set_size = 20;\n\n    client.sadd(\"bigset\", \"a member\");\n    client.sadd(\"bigset\", \"another member\");\n\n    while (set_size > 0) {\n        client.sadd(\"bigset\", \"member \" + set_size);\n        set_size -= 1;\n    }\n\n    // multi chain with an individual callback\n    client.multi()\n        .scard(\"bigset\")\n        .smembers(\"bigset\")\n        .keys(\"*\", function (err, replies) {\n            // NOTE: code in this callback is NOT atomic\n            // this only happens after the the .exec call finishes.\n            client.mget(replies, redis.print);\n        })\n        .dbsize()\n        .exec(function (err, replies) {\n            console.log(\"MULTI got \" + replies.length + \" replies\");\n            replies.forEach(function (reply, index) {\n                console.log(\"Reply \" + index + \": \" + reply.toString());\n            });\n        });\n```\n\n`client.multi()` is a constructor that returns a `Multi` object.  `Multi` objects share all of the\nsame command methods as `client` objects do.  Commands are queued up inside the `Multi` object\nuntil `Multi.exec()` is invoked.\n\nYou can either chain together `MULTI` commands as in the above example, or you can queue individual\ncommands while still sending regular client command as in this example:\n\n```js\n    var redis  = require(\"redis\"),\n        client = redis.createClient(), multi;\n\n    // start a separate multi command queue\n    multi = client.multi();\n    multi.incr(\"incr thing\", redis.print);\n    multi.incr(\"incr other thing\", redis.print);\n\n    // runs immediately\n    client.mset(\"incr thing\", 100, \"incr other thing\", 1, redis.print);\n\n    // drains multi queue and runs atomically\n    multi.exec(function (err, replies) {\n        console.log(replies); // 101, 2\n    });\n\n    // you can re-run the same transaction if you like\n    multi.exec(function (err, replies) {\n        console.log(replies); // 102, 3\n        client.quit();\n    });\n```\n\nIn addition to adding commands to the `MULTI` queue individually, you can also pass an array\nof commands and arguments to the constructor:\n\n```js\n    var redis  = require(\"redis\"),\n        client = redis.createClient(), multi;\n\n    client.multi([\n        [\"mget\", \"multifoo\", \"multibar\", redis.print],\n        [\"incr\", \"multifoo\"],\n        [\"incr\", \"multibar\"]\n    ]).exec(function (err, replies) {\n        console.log(replies);\n    });\n```\n\n\n## Monitor mode\n\nRedis supports the `MONITOR` command, which lets you see all commands received by the Redis server\nacross all client connections, including from other client libraries and other computers.\n\nAfter you send the `MONITOR` command, no other commands are valid on that connection.  `node_redis`\nwill emit a `monitor` event for every new monitor message that comes across.  The callback for the\n`monitor` event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```js\n    var client  = require(\"redis\").createClient(),\n        util = require(\"util\");\n\n    client.monitor(function (err, res) {\n        console.log(\"Entering monitoring mode.\");\n    });\n\n    client.on(\"monitor\", function (time, args) {\n        console.log(time + \": \" + util.inspect(args));\n    });\n```\n\n# Extras\n\nSome other things you might like to know about.\n\n## client.server_info\n\nAfter the ready probe completes, the results from the INFO command are saved in the `client.server_info`\nobject.\n\nThe `versions` key contains an array of the elements of the version string for easy comparison.\n\n    > client.server_info.redis_version\n    '2.3.0'\n    > client.server_info.versions\n    [ 2, 3, 0 ]\n\n## redis.print()\n\nA handy callback function for displaying return values when testing.  Example:\n\n```js\n    var redis = require(\"redis\"),\n        client = redis.createClient();\n\n    client.on(\"connect\", function () {\n        client.set(\"foo_rand000000000000\", \"some fantastic value\", redis.print);\n        client.get(\"foo_rand000000000000\", redis.print);\n    });\n```\n\nThis will print:\n\n    Reply: OK\n    Reply: some fantastic value\n\nNote that this program will not exit cleanly because the client is still connected.\n\n## redis.debug_mode\n\nBoolean to enable debug mode and protocol tracing.\n\n```js\n    var redis = require(\"redis\"),\n        client = redis.createClient();\n\n    redis.debug_mode = true;\n\n    client.on(\"connect\", function () {\n        client.set(\"foo_rand000000000000\", \"some fantastic value\");\n    });\n```\n\nThis will display:\n\n    mjr:~/work/node_redis (master)$ node ~/example.js\n    send command: *3\n    $3\n    SET\n    $20\n    foo_rand000000000000\n    $20\n    some fantastic value\n\n    on_data: +OK\n\n`send command` is data sent into Redis and `on_data` is data received from Redis.\n\n## client.send_command(command_name, args, callback)\n\nUsed internally to send commands to Redis.  For convenience, nearly all commands that are published on the Redis\nWiki have been added to the `client` object.  However, if I missed any, or if new commands are introduced before\nthis library is updated, you can use `send_command()` to send arbitrary commands to Redis.\n\nAll commands are sent as multi-bulk commands.  `args` can either be an Array of arguments, or omitted.\n\n## client.connected\n\nBoolean tracking the state of the connection to the Redis server.\n\n## client.command_queue.length\n\nThe number of commands that have been sent to the Redis server but not yet replied to.  You can use this to\nenforce some kind of maximum queue depth for commands while connected.\n\nDon't mess with `client.command_queue` though unless you really know what you are doing.\n\n## client.offline_queue.length\n\nThe number of commands that have been queued up for a future connection.  You can use this to enforce\nsome kind of maximum queue depth for pre-connection commands.\n\n## client.retry_delay\n\nCurrent delay in milliseconds before a connection retry will be attempted.  This starts at `250`.\n\n## client.retry_backoff\n\nMultiplier for future retry timeouts.  This should be larger than 1 to add more time between retries.\nDefaults to 1.7.  The default initial connection retry is 250, so the second retry will be 425, followed by 723.5, etc.\n\n### Commands with Optional and Keyword arguments\n\nThis applies to anything that uses an optional `[WITHSCORES]` or `[LIMIT offset count]` in the [redis.io/commands](http://redis.io/commands) documentation.\n\nExample:\n```js\nvar args = [ 'myzset', 1, 'one', 2, 'two', 3, 'three', 99, 'ninety-nine' ];\nclient.zadd(args, function (err, response) {\n    if (err) throw err;\n    console.log('added '+response+' items.');\n\n    // -Infinity and +Infinity also work\n    var args1 = [ 'myzset', '+inf', '-inf' ];\n    client.zrevrangebyscore(args1, function (err, response) {\n        if (err) throw err;\n        console.log('example1', response);\n        // write your code here\n    });\n\n    var max = 3, min = 1, offset = 1, count = 2;\n    var args2 = [ 'myzset', max, min, 'WITHSCORES', 'LIMIT', offset, count ];\n    client.zrevrangebyscore(args2, function (err, response) {\n        if (err) throw err;\n        console.log('example2', response);\n        // write your code here\n    });\n});\n```\n\n## TODO\n\nBetter tests for auth, disconnect/reconnect, and all combinations thereof.\n\nStream large set/get values into and out of Redis.  Otherwise the entire value must be in node's memory.\n\nPerformance can be better for very large values.\n\nI think there are more performance improvements left in there for smaller values, especially for large lists of small values.\n\n## How to Contribute\n- open a pull request and then wait for feedback (if\n  [DTrejo](http://github.com/dtrejo) does not get back to you within 2 days,\n  comment again with indignation!)\n\n## Contributors\nSome people have have added features and fixed bugs in `node_redis` other than me.\n\nOrdered by date of first contribution.\n[Auto-generated](http://github.com/dtrejo/node-authors) on Wed Jul 25 2012 19:14:59 GMT-0700 (PDT).\n\n- [Matt Ranney aka `mranney`](https://github.com/mranney)\n- [Tim-Smart aka `tim-smart`](https://github.com/tim-smart)\n- [Tj Holowaychuk aka `visionmedia`](https://github.com/visionmedia)\n- [rick aka `technoweenie`](https://github.com/technoweenie)\n- [Orion Henry aka `orionz`](https://github.com/orionz)\n- [Aivo Paas aka `aivopaas`](https://github.com/aivopaas)\n- [Hank Sims aka `hanksims`](https://github.com/hanksims)\n- [Paul Carey aka `paulcarey`](https://github.com/paulcarey)\n- [Pieter Noordhuis aka `pietern`](https://github.com/pietern)\n- [nithesh aka `nithesh`](https://github.com/nithesh)\n- [Andy Ray aka `andy2ray`](https://github.com/andy2ray)\n- [unknown aka `unknowdna`](https://github.com/unknowdna)\n- [Dave Hoover aka `redsquirrel`](https://github.com/redsquirrel)\n- [Vladimir Dronnikov aka `dvv`](https://github.com/dvv)\n- [Umair Siddique aka `umairsiddique`](https://github.com/umairsiddique)\n- [Louis-Philippe Perron aka `lp`](https://github.com/lp)\n- [Mark Dawson aka `markdaws`](https://github.com/markdaws)\n- [Ian Babrou aka `bobrik`](https://github.com/bobrik)\n- [Felix Geisendorfer aka `felixge`](https://github.com/felixge)\n- [Jean-Hugues Pinson aka `undefined`](https://github.com/undefined)\n- [Maksim Lin aka `maks`](https://github.com/maks)\n- [Owen Smith aka `orls`](https://github.com/orls)\n- [Zachary Scott aka `zzak`](https://github.com/zzak)\n- [TEHEK Firefox aka `TEHEK`](https://github.com/TEHEK)\n- [Isaac Z. Schlueter aka `isaacs`](https://github.com/isaacs)\n- [David Trejo aka `DTrejo`](https://github.com/DTrejo)\n- [Brian Noguchi aka `bnoguchi`](https://github.com/bnoguchi)\n- [Philip Tellis aka `bluesmoon`](https://github.com/bluesmoon)\n- [Marcus Westin aka `marcuswestin2`](https://github.com/marcuswestin2)\n- [Jed Schmidt aka `jed`](https://github.com/jed)\n- [Dave Peticolas aka `jdavisp3`](https://github.com/jdavisp3)\n- [Trae Robrock aka `trobrock`](https://github.com/trobrock)\n- [Shankar Karuppiah aka `shankar0306`](https://github.com/shankar0306)\n- [Ignacio Burgueo aka `ignacio`](https://github.com/ignacio)\n\nThanks.\n\n## LICENSE - \"MIT License\"\n\nCopyright (c) 2010 Matthew Ranney, http://ranney.com/\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n\n![spacer](http://ranney.com/1px.gif)\n",
node_modules/karma/node_modules/socket.io/node_modules/redis/README.md:608:## TODO
node_modules/karma/node_modules/socket.io/node_modules/redis/test.js:561:// TODO - add test for HMSET with optional callbacks
node_modules/karma/node_modules/socket.io/node_modules/redis/test.js:1373:    // TODO - sort by hash value
node_modules/karma/node_modules/socket.io/node_modules/redis/test.js:1538:// TODO - need a better way to test auth, maybe auto-config a local Redis server or something.
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/dist/socket.io.js:2854:      // TODO implement jsEvent.wasClean
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/lib/vendor/web-socket-js/flash-src/com/hurlant/crypto/rsa/RSAKey.as:327:			// TODO: re-calculate any missing CRT params
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/lib/vendor/web-socket-js/flash-src/com/hurlant/crypto/symmetric/AESKey.as:27:		// TODO:
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/lib/vendor/web-socket-js/flash-src/com/hurlant/crypto/tls/SSLSecurityParameters.as:276:			// TODO: Implement this, but I don't forsee it being necessary at this point in time, since for purposes
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/lib/vendor/web-socket-js/flash-src/com/hurlant/crypto/tls/TLSEngine.as:524:			// TODO: Modify to handle case of requesting a certificate from the client, for "client authentication", 
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/lib/vendor/web-socket-js/web_socket.js:158:      // TODO implement jsEvent.wasClean
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/active-x-obfuscator/node_modules/zeparser/benchmark.html:21284:  FH=((n1&0xFFF)+(n2&0xFFF))>0xFFF; // TODO test bit 11. Not sure on this
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/active-x-obfuscator/node_modules/zeparser/benchmark.html:21373:  'FZ=(RA==0);'+ // TODO not sure. on z80 Z is not affected
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/active-x-obfuscator/node_modules/zeparser/benchmark.html:22497:        // TODO not sure on this
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/active-x-obfuscator/node_modules/zeparser/benchmark.html:22636:function where_mem(a) { // TODO rewrite this
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/active-x-obfuscator/node_modules/zeparser/benchmark.html:22979:    case 0: gbMemory[_P1_]=gbPin14 & gbPin15; return; // TODO not sure on this
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/active-x-obfuscator/node_modules/zeparser/benchmark.html:22982:    case 3: gbMemory[_P1_]=0xFF; return; // TODO not sure on this
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/active-x-obfuscator/node_modules/zeparser/benchmark.html:23276:    // Draw Window - TODO this could be buggy
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/active-x-obfuscator/node_modules/zeparser/benchmark.html:23305:        // TODO handle Y flipped sprites with size = 16
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/active-x-obfuscator/node_modules/zeparser/benchmark.html:43359:	// TODO: Fix this.
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/active-x-obfuscator/node_modules/zeparser/benchmark.html:47540:  // TODO: allow reseeding after first request
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/active-x-obfuscator/node_modules/zeparser/benchmark.html:47732:  // TODO: re-calculate any missing CRT params
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/active-x-obfuscator/node_modules/zeparser/benchmark.html:50394:// TODO: eval/scheme-report-environment/null-environment/interaction-environment
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/active-x-obfuscator/node_modules/zeparser/benchmark.html:50725:// TODO: call/cc stuff
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/active-x-obfuscator/node_modules/zeparser/benchmark.html:51554:    // TODO sc_Struct
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/active-x-obfuscator/node_modules/zeparser/benchmark.html:52089:	// TODO: care for symbols with spaces (escape-chars symbols).
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/active-x-obfuscator/node_modules/zeparser/benchmark.html:52099:	// TODO: care for symbols with spaces (escape-chars symbols).
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/active-x-obfuscator/node_modules/zeparser/benchmark.html:56499:        /* TODO: dynamically include other scripts */
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/active-x-obfuscator/node_modules/zeparser/benchmark.html:56633:                /* TODO */
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/active-x-obfuscator/node_modules/zeparser/benchmark.html:70054:throw"TODO: not implemented"
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/active-x-obfuscator/node_modules/zeparser/benchmark.html:110030:e[a++]="<!-- TODO -->";
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/active-x-obfuscator/node_modules/zeparser/Tokenizer.js:206:				// TODO: something like this: var regexmatch = /([^\']|$)+/.match();
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/uglify-js/tmp/app.js:1500:			// TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/uglify-js/tmp/app.js:1535:		// TODO: This is a hack for 1.5 ONLY. It will be removed in 1.6. Users should
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/uglify-js/tmp/app.js:1635:			// TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/uglify-js/tmp/app.js:1773:// TODO: This is a hack for 1.5 ONLY to allow objects with a single toJSON
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/uglify-js/tmp/app.js:2907:			// TODO: Stop taunting the data cache; remove global events and always attach to document
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/uglify-js/tmp/app.js:4315:			// TODO: Move to normal caching system
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/uglify-js/tmp/app.js:13349:          // TODO(david): Handle a listener that is not a function, but instead an object that implements the
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/uglify-js/tmp/app.js:13410:        // TODO(david): Expose some information about the xmlhttprequest to the exception logging (maybe request url)
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/uglify-js/tmp/app.js:13459: * TODO(david): show a message to the user. Let the user elect to send more detailed error information (un-redacted
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/uglify-js/tmp/app.js:15323:        // TODO introduce global settings, allowing the client to modify them for all requests, not only timeout		
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/uglify-js/tmp/app.js:15463:// TODO JsDoc
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/ws/build/gyp-mac-tool:55:      # TODO(thakis): This copies file attributes like mtime, while the
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/ws/build/Makefile:62:# TODO(evan): move all cross-compilation logic to gyp-time so we don't need
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/ws/lib/WebSocket.js:55:  // TODO: actually handle the `Sub-Protocols` part of the WebSocket client
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/ws/node_modules/nan/nan.h:793:      // TODO(isaacs): THIS IS AWFUL!!!
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/xmlhttprequest/lib/XMLHttpRequest.js:232:    // @TODO Make this case insensitive
node_modules/karma/node_modules/socket.io/node_modules/socket.io-client/node_modules/xmlhttprequest/lib/XMLHttpRequest.js:543:        // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)
node_modules/karma/node_modules/source-map/test/source-map/test-util.js:202:  // TODO Issue #128: Define and test this function properly.
node_modules/karma/node_modules/useragent/index.js:487: * @TODO We probably want to create 2 dictionary's here 1 for the Agent
node_modules/karma/static/karma.js:69:        // TODO(vojta): show what test (with explanation about jasmine.UPDATE_INTERVAL)
node_modules/karma/static/karma.js:162:      // TODO(vojta): can we rather get notification from socket.io?
node_modules/karma/static/karma.js:172:    // TODO(vojta): introduce special API for this
node_modules/karma/static/karma.js:207:      // TODO(vojta): clone objects + deep
node_modules/karma/static/karma.js:213:  // TODO(vojta): support multiple callbacks (queue)
node_modules/karma/static/karma.js:235:    // TODO(vojta): make resultsBufferLimit configurable
node_modules/karma-jasmine/lib/adapter.js:95:    // TODO(vojta): Do not send spec names when polling.
node_modules/karma-jasmine/lib/jasmine.js:290:        fn.call(this, callDone); //TODO: do we care about more than 1 arg?
node_modules/karma-jasmine/lib/jasmine.js:477:    // TODO: we may just be able to pass in the fn instead of wrapping here
node_modules/karma-jasmine/lib/jasmine.js:487:    // TODO: fix this naming, and here's where the value comes in
node_modules/karma-jasmine/lib/jasmine.js:526:      resultCallback: function() {} // TODO - hook this up
node_modules/karma-jasmine/lib/jasmine.js:569:        //TODO?: should this return the current spy? Downside: may cause user confusion about spy state
node_modules/karma-jasmine/lib/jasmine.js:1208:      // TODO: how many of these params are needed?
node_modules/karma-jasmine/lib/jasmine.js:1216:          expected: expected // TODO: this may need to be arrayified/sliced
node_modules/karma-jasmine/lib/jasmine.js:1248:    // TODO: this would be nice as its own Object - NegativeExpectation
node_modules/karma-jasmine/lib/jasmine.js:1249:    // TODO: copy instead of mutate options
node_modules/karma-jasmine/lib/jasmine.js:1259://TODO: expectation result may make more sense as a presentation of an expectation.
node_modules/karma-jasmine/lib/jasmine.js:1530:        //TODO: set a var when we catch an exception and
node_modules/karma-jasmine/lib/jasmine.js:1739:  // TODO: what to do about jasmine.pp not being inject? move to JSON.stringify? gut PrettyPrinter?
node_modules/karma-traceur-preprocessor/index.js:33:    // TODO(vojta): Tracer should return JS object, rather than a string.
node_modules/requirejs/bin/r.js:7544:            // TODO(ikarienator): Should we update the test cases instead?
node_modules/requirejs/bin/r.js:8390:// TODO(user) Consolidation of mathematical values found in numeric literals.
node_modules/requirejs/bin/r.js:8391:// TODO(user) Unconsolidation.
node_modules/requirejs/bin/r.js:8392:// TODO(user) Consolidation of ECMA-262 6th Edition programs.
node_modules/requirejs/bin/r.js:8393:// TODO(user) Rewrite in ECMA-262 6th Edition.
node_modules/requirejs/bin/r.js:26711:                    // TODO: need to generalize this work, maybe also reuse
node_modules/traceur/node_modules/glob/node_modules/minimatch/test/basic.js:3:// TODO: Some of these tests do very bad things with backslashes, and will
node_modules/traceur/node_modules/glob/node_modules/minimatch/test/defaults.js:3:// TODO: Some of these tests do very bad things with backslashes, and will
node_modules/traceur/src/node/command.js:113:  // TODO: Start trepl
node_modules/traceur/src/node/deferred.js:103:  // TODO: find and wrap everything that needs to be wrapped.
node_modules/vinyl-sourcemaps-apply/node_modules/source-map/test/source-map/test-util.js:202:  // TODO Issue #128: Define and test this function properly.
src/js/app.js:84:            // TODO server should respond with detail error texts;
src/js/campaign/campaignDetailsController.js:16:        // TODO ->
src/js/campaign/campaignDetailsController.js:76:        // TODO
src/js/query/queryController.js:69:    // TODO get Product from select
views/campaign-details.html:55:                <!-- TODO fn DeleteProspect only works for new queries, not selecting saved ones -->
views/campaign-details.html:294:.fc-state-highlight { /* <td> today cell */ /* TODO: add .fc-today to <th> */
views/campaign-details.html:650:	min-height: 34px; /* TODO: doesnt work well in quirksmode */
views/campaign-details.html:737:.fc .ui-draggable-dragging .fc-event-bg, /* TODO: something nicer like .fc-opacity */
views/campaign-details.html:756:.fc-agenda .ui-resizable-resizing { /* TODO: better selector */
views/newcampaign.html:79:     <!-- TODO fn DeleteProspect only works for new queries, not selecting saved ones -->
views/newQuery.html:151:      <!-- TODO fn DeleteProspect only works for new queries, not selecting saved ones -->
